<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>B√πi H√†o ‚Äî Lotto ULTRA MASTER (FIX)</title>

<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

<style>
  body{margin:0;font-family:system-ui;background:#0b1220;color:#fff;padding:12px}
  .card{background:#111827;border-radius:18px;padding:14px;margin-bottom:12px;box-shadow:0 0 0 1px rgba(255,255,255,.06)}
  h1{font-size:18px;margin:0 0 6px}
  .badge{display:inline-block;background:#1e293b;padding:4px 10px;border-radius:999px;font-size:12px}
  button{padding:10px 14px;border-radius:12px;border:none;font-weight:700}
  .primary{background:#2563eb;color:white}
  textarea{width:100%;border-radius:12px;border:none;padding:10px;background:#020617;color:#fff;margin-top:6px}
  canvas{max-width:100%;border-radius:12px;margin-top:8px}
</style>
</head>

<body>

<div class="card">
  <h1>B√πi H√†o ‚Äî Lotto ULTRA MASTER (FIX)</h1>
  <div class="badge">OpenCV ‚Ä¢ AI OCR ‚Ä¢ Auto Row Detect ‚Ä¢ DB=5 digits ‚Ä¢ G6‚â†G7 ‚Ä¢ Gate ‚Ä¢ Batch</div>
  <p style="font-size:13px;opacity:.85">
    Upload nhi·ªÅu ·∫£nh KQXS ‚Üí AI t·ª± ƒë·ªçc ƒêB/G6/G7 ‚Üí l·ªçc d·ªØ li·ªáu s·∫°ch ‚Üí ch·∫°y FULL
  </p>

  <button class="primary" onclick="fileInput.click()">üì∏ Upload nhi·ªÅu ·∫£nh</button>
  <input id="fileInput" type="file" accept="image/*" multiple hidden>

  <div id="status" style="margin-top:6px;font-size:13px"></div>

  <canvas id="imgCanvas"></canvas>

  <textarea id="ocrDebug" rows="5" placeholder="OCR debug..."></textarea>
  <div id="ocrParsed" class="badge" style="margin-top:6px">--</div>
</div>

<div class="card">
  <h3>D·ªØ li·ªáu ƒë·∫ßu v√†o (m·ªói d√≤ng = 1 ng√†y)</h3>
  <textarea id="inputData" rows="7"></textarea>
  <button class="primary" onclick="runFULL()">üöÄ Ch·∫°y FULL</button>
</div>

<div class="card">
  <h3>K·∫æT QU·∫¢ FULL</h3>
  <pre id="output"></pre>
</div>

<script>
const fileInput = document.getElementById("fileInput");
const imgCanvas = document.getElementById("imgCanvas");
const ctx = imgCanvas.getContext("2d");
const statusEl = document.getElementById("status");
const ocrDebug = document.getElementById("ocrDebug");
const ocrParsed = document.getElementById("ocrParsed");
const inputData = document.getElementById("inputData");
const output = document.getElementById("output");

let loadedImg = null;
let cvReady = false;
let crop = {x:0,y:0,w:0,h:0};
let parsedLineBuffer = "";

(function waitCV(){
  const t = setInterval(()=>{
    if(window.cv && cv.Mat){cvReady=true;clearInterval(t)}
  },80);
})();

function setStatus(t){statusEl.textContent=t}

// ==== IMAGE LOAD / BATCH ====
fileInput.addEventListener("change", async e=>{
  const files=[...e.target.files];
  if(!files.length) return;

  // kh√¥ng x√≥a input n·∫øu mu·ªën ‚Äúb·ªï sung th√™m ·∫£nh‚Äù th√¨ comment d√≤ng d∆∞·ªõi
  // inputData.value="";

  for(let i=0;i<files.length;i++){
    setStatus(`ƒêang x·ª≠ l√Ω ·∫£nh ${i+1}/${files.length}...`);
    await loadFile(files[i]);
    const ok = await scanImage();
    if(ok && parsedLineBuffer){
      inputData.value += (inputData.value ? "\n" : "") + parsedLineBuffer;
      parsedLineBuffer = "";
    }
  }
  setStatus("Batch xong ‚Üí ch·∫°y FULL");
  runFULL();
});

function loadFile(file){
  return new Promise(resolve=>{
    const url=URL.createObjectURL(file);
    const img=new Image();
    img.onload=()=>{
      loadedImg=img;
      const scale=Math.min(1,(window.innerWidth-24)/img.width);
      imgCanvas.width=Math.floor(img.width*scale);
      imgCanvas.height=Math.floor(img.height*scale);
      crop={x:0,y:0,w:imgCanvas.width,h:imgCanvas.height};
      draw();
      resolve();
    };
    img.src=url;
  });
}

function draw(){
  ctx.clearRect(0,0,imgCanvas.width,imgCanvas.height);
  ctx.drawImage(loadedImg,0,0,imgCanvas.width,imgCanvas.height);
}

// ==== OCR UTIL ====
function takeLast2(text){
  const nums=(String(text).match(/\d{2,6}/g)||[]);
  return nums.map(n=>n.slice(-2)).filter(x=>/^\d{2}$/.test(x));
}

function findFiveDigit(text){
  // t√¨m ƒë√∫ng ƒêB d·∫°ng 5 ch·ªØ s·ªë
  const m = String(text).match(/\d{5}/g);
  return m ? m[0] : "";
}

async function ocrDigits(canvas){
  const res=await Tesseract.recognize(canvas,"eng",{
    tessedit_char_whitelist:"0123456789",
    tessedit_pageseg_mode:"7"
  });
  return res.data.text||"";
}

function preprocess(mat){
  let gray=new cv.Mat();
  cv.cvtColor(mat,gray,cv.COLOR_RGBA2GRAY);

  // upscale ƒë·ªÉ OCR d·ªÖ h∆°n
  let up=new cv.Mat();
  cv.resize(gray,up,new cv.Size(0,0),3,3,cv.INTER_CUBIC);

  let blur=new cv.Mat();
  cv.GaussianBlur(up,blur,new cv.Size(3,3),0);

  let bin=new cv.Mat();
  cv.threshold(blur,bin,0,255,cv.THRESH_BINARY+cv.THRESH_OTSU);

  gray.delete(); up.delete(); blur.delete();
  return bin;
}

function canvasFromMat(mat){
  const c=document.createElement("canvas");
  c.width=mat.cols;c.height=mat.rows;
  cv.imshow(c,mat);
  return c;
}

// ==== ROW SCAN HELPERS ====
// scoring theo m·ª•c ti√™u: DB c·∫ßn 5 ch·ªØ s·ªë; G6 c·∫ßn 3 c·∫∑p; G7 c·∫ßn 4 c·∫∑p.
// N·∫øu sai m·ª•c ti√™u ‚Üí ph·∫°t m·∫°nh ƒë·ªÉ kh√¥ng ch·ªçn nh·∫ßm.
function scorePairs(pairs, targetCount){
  const n = pairs.length;
  if(n === targetCount) return 1.0;
  if(targetCount===3 && n===4) return 0.05; // c·ª±c ph·∫°t ƒë·ªÉ G6 kh√¥ng ƒÉn nh·∫ßm G7
  if(targetCount===4 && n===3) return 0.2;
  if(n===2) return 0.4;
  if(n===1) return 0.2;
  return 0;
}

async function bestRowBySliding(body, yStart, yEnd, hRatio, targetCount){
  const H=body.rows,W=body.cols;
  const leftCut=Math.floor(W*0.12);
  const rightCut=Math.floor(W*0.02);
  const Wn=Math.max(10,W-leftCut-rightCut);

  const y1=Math.floor(H*yStart);
  const y2=Math.floor(H*yEnd);
  const winH=Math.max(20,Math.floor(H*hRatio));
  const step=Math.max(10,Math.floor(winH*0.35));

  let best={score:-1,text:"",pairs:[]};

  for(let y=y1;y<=y2-winH;y+=step){
    const roi=body.roi(new cv.Rect(leftCut,y,Wn,winH));
    const bin=preprocess(roi);
    roi.delete();

    const c=canvasFromMat(bin);
    bin.delete();

    const txt=await ocrDigits(c);
    const pairs=takeLast2(txt).slice(0,8);
    const s=scorePairs(pairs, targetCount);

    if(s>best.score){
      best={score:s,text:txt,pairs};
    }
    if(best.score>=0.95) break;
  }
  return best;
}

// DB scan: qu√©t v√πng tr√™n ƒë·ªÉ b·∫Øt ƒë√∫ng s·ªë 5 ch·ªØ s·ªë (tr√°nh d√≠nh 11UG/13UG)
async function bestDBBySliding(body){
  const H=body.rows,W=body.cols;
  const leftCut=Math.floor(W*0.08);
  const rightCut=Math.floor(W*0.08);
  const Wn=Math.max(10,W-leftCut-rightCut);

  // DB th∆∞·ªùng n·∫±m kho·∫£ng 20% - 55% chi·ªÅu cao body (tu·ª≥ UI)
  const y1=Math.floor(H*0.18);
  const y2=Math.floor(H*0.60);
  const winH=Math.max(28,Math.floor(H*0.10));
  const step=Math.max(12,Math.floor(winH*0.35));

  let best={score:-1,text:"",five:""};

  for(let y=y1;y<=y2-winH;y+=step){
    const roi=body.roi(new cv.Rect(leftCut,y,Wn,winH));
    const bin=preprocess(roi);
    roi.delete();

    const c=canvasFromMat(bin);
    bin.delete();

    const txt=await ocrDigits(c);
    const five=findFiveDigit(txt);
    const score = five ? 1.0 : 0.0;

    if(score>best.score){
      best={score,text:txt,five};
    }
    if(best.score>=0.95) break;
  }
  return best;
}

// ==== MAIN SCAN ====
async function scanImage(){
  if(!cvReady){setStatus("OpenCV ch∆∞a s·∫µn s√†ng");return false}

  // render crop -> temp canvas
  const tmp=document.createElement("canvas");
  tmp.width=crop.w; tmp.height=crop.h;
  tmp.getContext("2d").drawImage(imgCanvas,crop.x,crop.y,crop.w,crop.h,0,0,tmp.width,tmp.height);

  let src=cv.imread(tmp);
  let H=src.rows,W=src.cols;

  // body crop lo·∫°i header/footer nh·∫π
  const topCut=Math.floor(H*0.08);
  const botCut=Math.floor(H*0.06);
  const body=src.roi(new cv.Rect(0,topCut,W,Math.max(10,H-topCut-botCut)));

  // 1) DB: d√≤ s·ªë 5 ch·ªØ s·ªë
  const dbBest = await bestDBBySliding(body);
  const DB = dbBest.five ? dbBest.five.slice(-2) : "";

  // 2) G6: target 3 c·∫∑p (92 55 54)
  const g6Best = await bestRowBySliding(body, 0.68, 0.94, 0.09, 3);
  const G6 = (g6Best.pairs||[]).slice(0,3);

  // 3) G7: target 4 c·∫∑p (03 82 85 81)
  const g7Best = await bestRowBySliding(body, 0.78, 0.99, 0.10, 4);
  const G7 = (g7Best.pairs||[]).slice(0,4);

  body.delete(); src.delete();

  // debug
  ocrDebug.value =
`[DB_SCAN] ${dbBest.text}
[DB_5DIG] ${dbBest.five || "(none)"}

[G6_ROW] ${g6Best.text}
[G7_ROW] ${g7Best.text}`;

  ocrParsed.textContent = `DB:${DB||"--"} | G6:${G6.join(" ")||"--"} | G7:${G7.join(" ")||"--"}`;

  // gate
  const pass = !!DB && G6.length===3 && G7.length===4;

  if(pass){
    parsedLineBuffer = `DB ${DB} | G7: ${G7.join(" ")} | G6: ${G6.join(" ")}`;
    setStatus("Scan OK ‚úÖ (ƒë√£ ƒë·ªï d·ªØ li·ªáu)");
    return true;
  } else {
    setStatus("Scan FAIL ‚ùå (·∫£nh b·ªã lo·∫°i ‚Äî kh√¥ng l√†m b·∫©n d·ªØ li·ªáu)");
    parsedLineBuffer = "";
    return false;
  }
}

// ==== FULL ENGINE (t·∫°m: th·ªëng k√™ hot ƒë∆°n gi·∫£n) ====
function runFULL(){
  const lines=inputData.value.trim().split("\n").filter(Boolean);
  if(lines.length<3){
    output.textContent="‚ùå C·∫ßn ‚â•3 ng√†y d·ªØ li·ªáu";
    return;
  }

  let freq={};
  lines.forEach(line=>{
    const nums=(line.match(/\b\d{2}\b/g)||[]);
    nums.forEach(n=>freq[n]=(freq[n]||0)+1);
  });

  const sorted=Object.entries(freq).sort((a,b)=>b[1]-a[1]);

  const main=sorted[0]?.[0]||"--";
  const sub=sorted[1]?.[0]||"--";

  output.textContent=
`T·ªïng ng√†y: ${lines.length}

TOP HOT:
${sorted.slice(0,12).map(x=>x[0]+" ‚Üí "+x[1]).join("\n")}

CH·ªêT G·ª¢I √ù:
üéØ Ch√≠nh: ${main}
üõ° Ph·ª•: ${sub}

* Tool th·ªëng k√™ h·ªó tr·ª£, kh√¥ng ƒë·∫£m b·∫£o tr√∫ng`;
}
</script>

</body>
</html>
