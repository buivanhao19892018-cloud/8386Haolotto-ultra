<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>B√πi H√†o ‚Äî Lotto ULTRA MASTER</title>

<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

<style>
body{margin:0;font-family:system-ui;background:#0b1220;color:#fff;padding:12px}
.card{background:#111827;border-radius:18px;padding:14px;margin-bottom:12px;box-shadow:0 0 0 1px rgba(255,255,255,.06)}
h1{font-size:18px;margin:0 0 6px}
.badge{display:inline-block;background:#1e293b;padding:4px 10px;border-radius:999px;font-size:12px}
button{padding:10px 14px;border-radius:12px;border:none;font-weight:700}
.primary{background:#2563eb;color:white}
.gray{background:#374151;color:white}
textarea{width:100%;border-radius:12px;border:none;padding:10px;background:#020617;color:#fff;margin-top:6px}
canvas{max-width:100%;border-radius:12px;margin-top:8px}
.ok{color:#22c55e}
.fail{color:#ef4444}
</style>
</head>

<body>

<div class="card">
<h1>B√πi H√†o ‚Äî Lotto ULTRA MASTER</h1>
<div class="badge">OpenCV ‚Ä¢ AI OCR ‚Ä¢ Auto Row Detect ‚Ä¢ Gate ‚Ä¢ Batch ‚Ä¢ FULL</div>
<p style="font-size:13px;opacity:.85">Upload nhi·ªÅu ·∫£nh KQXS ‚Üí AI t·ª± ƒë·ªçc ƒêB/G6/G7 ‚Üí l·ªçc d·ªØ li·ªáu s·∫°ch ‚Üí ch·∫°y FULL</p>

<button class="primary" onclick="fileInput.click()">üì∏ Upload nhi·ªÅu ·∫£nh</button>
<input id="fileInput" type="file" accept="image/*" multiple hidden>

<div id="status" style="margin-top:6px;font-size:13px"></div>

<canvas id="imgCanvas"></canvas>

<textarea id="ocrDebug" rows="4" placeholder="OCR debug..."></textarea>
<div id="ocrParsed" class="badge" style="margin-top:6px">--</div>
</div>

<div class="card">
<h3>D·ªØ li·ªáu ƒë·∫ßu v√†o (m·ªói d√≤ng = 1 ng√†y)</h3>
<textarea id="inputData" rows="6"></textarea>
<button class="primary" onclick="runFULL()">üöÄ Ch·∫°y FULL</button>
</div>

<div class="card">
<h3>K·∫æT QU·∫¢ FULL</h3>
<pre id="output"></pre>
</div>

<script>
const fileInput = document.getElementById("fileInput");
const imgCanvas = document.getElementById("imgCanvas");
const ctx = imgCanvas.getContext("2d");
const statusEl = document.getElementById("status");
const ocrDebug = document.getElementById("ocrDebug");
const ocrParsed = document.getElementById("ocrParsed");
const inputData = document.getElementById("inputData");
const output = document.getElementById("output");

let loadedImg = null;
let cvReady = false;
let crop = {x:0,y:0,w:0,h:0};

(function waitCV(){
  const t = setInterval(()=>{
    if(window.cv && cv.Mat){cvReady=true;clearInterval(t)}
  },80);
})();

function setStatus(t){statusEl.textContent=t}

// LOAD IMAGE
fileInput.addEventListener("change", async e=>{
  const files=[...e.target.files];
  inputData.value="";
  for(let i=0;i<files.length;i++){
    setStatus(`ƒêang x·ª≠ l√Ω ·∫£nh ${i+1}/${files.length}...`);
    await loadFile(files[i]);
    await scanImage();
    if(window.__parsedLine){
      inputData.value += (inputData.value?"\n":"") + window.__parsedLine;
      window.__parsedLine="";
    }
  }
  setStatus("Batch xong ‚Üí ch·∫°y FULL");
  runFULL();
});

function loadFile(file){
  return new Promise(resolve=>{
    const url=URL.createObjectURL(file);
    const img=new Image();
    img.onload=()=>{
      loadedImg=img;
      const scale=Math.min(1,(window.innerWidth-24)/img.width);
      imgCanvas.width=img.width*scale;
      imgCanvas.height=img.height*scale;
      crop={x:0,y:0,w:imgCanvas.width,h:imgCanvas.height};
      draw();
      resolve();
    };
    img.src=url;
  });
}

function draw(){
  ctx.drawImage(loadedImg,0,0,imgCanvas.width,imgCanvas.height);
}

// OCR UTIL
function takeLast2(text){
  const nums=(String(text).match(/\d{2,6}/g)||[]);
  return nums.map(n=>n.slice(-2)).filter(x=>/^\d{2}$/.test(x));
}

async function ocrDigits(canvas){
  const res=await Tesseract.recognize(canvas,"eng",{
    tessedit_char_whitelist:"0123456789",
    tessedit_pageseg_mode:"7"
  });
  return res.data.text||"";
}

function preprocess(mat){
  let gray=new cv.Mat();
  cv.cvtColor(mat,gray,cv.COLOR_RGBA2GRAY);
  let up=new cv.Mat();
  cv.resize(gray,up,new cv.Size(0,0),3,3,cv.INTER_CUBIC);
  let blur=new cv.Mat();
  cv.GaussianBlur(up,blur,new cv.Size(3,3),0);
  let bin=new cv.Mat();
  cv.threshold(blur,bin,0,255,cv.THRESH_BINARY+cv.THRESH_OTSU);
  gray.delete();up.delete();blur.delete();
  return bin;
}

function canvasFromMat(mat){
  const c=document.createElement("canvas");
  c.width=mat.cols;c.height=mat.rows;
  cv.imshow(c,mat);
  return c;
}

// SCAN ROW BY SLIDING WINDOW
async function bestRow(body, yStart, yEnd, hRatio){
  const H=body.rows,W=body.cols;
  const leftCut=Math.floor(W*0.12);
  const rightCut=Math.floor(W*0.02);
  const Wn=Math.max(10,W-leftCut-rightCut);

  const y1=Math.floor(H*yStart);
  const y2=Math.floor(H*yEnd);
  const winH=Math.max(18,Math.floor(H*hRatio));
  const step=Math.max(10,Math.floor(winH*0.35));

  let best={score:-1,text:"",pairs:[]};

  for(let y=y1;y<=y2-winH;y+=step){
    const roi=body.roi(new cv.Rect(leftCut,y,Wn,winH));
    const bin=preprocess(roi);
    roi.delete();
    const c=canvasFromMat(bin);
    bin.delete();
    const txt=await ocrDigits(c);
    const pairs=takeLast2(txt).slice(0,8);
    const n=pairs.length;
    let score = n===4?1 : n===3?0.9 : n===2?0.6 : n===1?0.3 : 0;
    if(score>best.score){
      best={score,text:txt,pairs};
    }
    if(score>=0.95) break;
  }
  return best;
}

// MAIN SCAN
async function scanImage(){
  if(!cvReady){setStatus("OpenCV ch∆∞a s·∫µn s√†ng");return}

  const tmp=document.createElement("canvas");
  tmp.width=crop.w; tmp.height=crop.h;
  tmp.getContext("2d").drawImage(imgCanvas,crop.x,crop.y,crop.w,crop.h,0,0,tmp.width,tmp.height);

  let src=cv.imread(tmp);
  let H=src.rows,W=src.cols;

  // body crop
  const topCut=Math.floor(H*0.10);
  const botCut=Math.floor(H*0.08);
  const body=src.roi(new cv.Rect(0,topCut,W,Math.max(10,H-topCut-botCut)));

  // DB row fixed zone
  const dbY1=Math.floor(body.rows*0.08);
  const dbY2=Math.floor(body.rows*0.24);
  const dbRow=body.roi(new cv.Rect(0,dbY1,W,Math.max(10,dbY2-dbY1)));
  const dbBin=preprocess(dbRow);
  dbRow.delete();
  const dbCanvas=canvasFromMat(dbBin);
  dbBin.delete();
  const dbText=await ocrDigits(dbCanvas);
  const DB=takeLast2(dbText)[0]||"";

  // Sliding detect G6 / G7
  const g6Best=await bestRow(body,0.72,0.92,0.08);
  const g7Best=await bestRow(body,0.82,0.99,0.10);
  body.delete(); src.delete();

  const G6=g6Best.pairs.slice(0,3);
  const G7=g7Best.pairs.slice(0,4);

  ocrDebug.value=
`[DB_ROW] ${dbText}
[G6_ROW] ${g6Best.text}
[G7_ROW] ${g7Best.text}`;

  ocrParsed.textContent=`DB:${DB||"--"} | G6:${G6.join(" ")||"--"} | G7:${G7.join(" ")||"--"}`;

  // GATE
  if(DB && G6.length===3 && G7.length===4){
    window.__parsedLine=`DB ${DB} | G7: ${G7.join(" ")} | G6: ${G6.join(" ")}`;
    setStatus("Scan OK ‚úÖ");
  } else {
    setStatus("Scan FAIL ‚ùå ‚Äî lo·∫°i ·∫£nh n√†y");
  }
}

// FULL ENGINE
function runFULL(){
  const lines=inputData.value.trim().split("\n").filter(Boolean);
  if(lines.length<3){
    output.textContent="‚ùå C·∫ßn ‚â•3 ng√†y d·ªØ li·ªáu";
    return;
  }

  let freq={};
  lines.forEach(line=>{
    const nums=(line.match(/\d{2}/g)||[]);
    nums.forEach(n=>freq[n]=(freq[n]||0)+1);
  });

  const sorted=Object.entries(freq).sort((a,b)=>b[1]-a[1]);

  const main=sorted[0]?.[0]||"--";
  const sub=sorted[1]?.[0]||"--";

  output.textContent=
`T·ªïng ng√†y: ${lines.length}

TOP HOT:
${sorted.slice(0,12).map(x=>x[0]+" ‚Üí "+x[1]).join("\n")}

CH·ªêT G·ª¢I √ù:
üéØ Ch√≠nh: ${main}
üõ° Ph·ª•: ${sub}

* Tool th·ªëng k√™ h·ªó tr·ª£, kh√¥ng ƒë·∫£m b·∫£o tr√∫ng`;
}
</script>

</body>
</html>
