<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>B√πi H√†o ‚Äî Lotto ULTRA MASTER ‚Ä¢ OCR Gate FINAL</title>

<!-- OpenCV + Tesseract (OCR) -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

<style>
  :root{
    --bg:#070b14; --card:#0b1220; --card2:#0f172a;
    --stroke:rgba(255,255,255,.08); --muted:rgba(255,255,255,.72);
    --text:#fff; --blue:#2563eb; --green:#16a34a; --red:#ef4444; --amber:#f59e0b;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:
    radial-gradient(1200px 700px at 20% 0%, rgba(37,99,235,.25), transparent 55%),
    radial-gradient(900px 600px at 100% 20%, rgba(22,163,74,.18), transparent 50%),
    radial-gradient(700px 450px at 40% 100%, rgba(239,68,68,.12), transparent 55%),
    var(--bg);
    color:var(--text); padding:14px;
  }
  .wrap{max-width:980px;margin:0 auto}
  .card{
    background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    border:1px solid var(--stroke);
    border-radius:18px; padding:14px; margin:12px 0;
    box-shadow:0 18px 50px rgba(0,0,0,.35);
    backdrop-filter: blur(10px);
  }
  h1{margin:0 0 6px;font-size:18px}
  h2{margin:0 0 10px;font-size:16px}
  p{margin:6px 0;color:var(--muted);font-size:13px;line-height:1.35}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .badge{
    display:inline-flex;gap:8px;align-items:center;
    padding:7px 10px;border-radius:999px;
    background:rgba(15,23,42,.75);
    border:1px solid var(--stroke);
    font-size:12px;color:rgba(255,255,255,.85);
  }
  .dot{width:8px;height:8px;border-radius:50%}
  .dot.ok{background:var(--green)}
  .dot.bad{background:var(--red)}
  .dot.warn{background:var(--amber)}
  .btn{
    padding:10px 12px;border-radius:14px;border:1px solid var(--stroke);
    background:rgba(15,23,42,.65); color:var(--text);
    font-weight:800; cursor:pointer;
  }
  .btn.primary{background:linear-gradient(180deg, rgba(37,99,235,.95), rgba(37,99,235,.78));border:none}
  .btn.danger{background:linear-gradient(180deg, rgba(239,68,68,.95), rgba(239,68,68,.78));border:none}
  .btn.ghost{background:rgba(15,23,42,.35)}
  .btn:active{transform:translateY(1px)}
  textarea, input{
    width:100%; padding:10px 12px;border-radius:14px;
    border:1px solid var(--stroke);
    background:rgba(2,6,23,.65); color:var(--text);
    font-size:13px; outline:none;
  }
  textarea{min-height:120px;resize:vertical}
  .grid{display:grid;grid-template-columns:1fr;gap:10px}
  @media(min-width:860px){.grid{grid-template-columns:1.1fr .9fr}}
  canvas{width:100%;border-radius:14px;border:1px solid var(--stroke);background:#020617}
  pre{white-space:pre-wrap;word-break:break-word;margin:0;color:rgba(255,255,255,.88);font-size:13px;line-height:1.35}
  .small{font-size:12px;color:rgba(255,255,255,.7)}
  .kv{display:grid;grid-template-columns:120px 1fr;gap:8px;align-items:center}
  .sep{height:1px;background:var(--stroke);margin:10px 0}
</style>
</head>

<body>
<div class="wrap">

  <div class="card">
    <h1>B√πi H√†o ‚Äî Lotto ULTRA MASTER (OCR Gate FINAL)</h1>
    <div class="row">
      <div class="badge"><span class="dot ok"></span>OpenCV</div>
      <div class="badge"><span class="dot ok"></span>OCR</div>
      <div class="badge"><span class="dot warn"></span>Gate c·ª©ng</div>
      <div class="badge"><span class="dot warn"></span>Batch nhi·ªÅu ·∫£nh</div>
      <div class="badge"><span class="dot warn"></span>DB theo nh√£n ‚ÄúƒêB/DB‚Äù + 5 s·ªë</div>
      <div class="badge"><span class="dot warn"></span>G7 theo m√†u ƒë·ªè</div>
      <div class="badge"><span class="dot warn"></span>G6 theo 3 s·ªë 3 ch·ªØ s·ªë ph√≠a tr√™n G7</div>
    </div>
    <p>
      Lu·ªìng chu·∫©n: <b>Upload ·∫£nh</b> ‚Üí Tool t·ª± c·∫Øt v√πng b·∫£ng ‚Üí <b>DB: t√¨m ch·ªØ ƒêB/DB + 5 s·ªë</b> ‚Üí <b>G7: b·∫Øt h√†ng ƒë·ªè</b> ‚Üí <b>G6: b·∫Øt 3 s·ªë 3 ch·ªØ s·ªë ngay tr√™n G7</b> ‚Üí Gate pass th√¨ m·ªõi ƒë·ªï v√†o d·ªØ li·ªáu ‚Üí ch·∫°y FULL.
      <br><span class="small">(*Tool th·ªëng k√™ h·ªó tr·ª£ ph√¢n t√≠ch, kh√¥ng ƒë·∫£m b·∫£o k·∫øt qu·∫£.)</span>
    </p>

    <div class="row" style="margin-top:8px">
      <button class="btn primary" id="btnUpload">üì∏ Upload nhi·ªÅu ·∫£nh</button>
      <button class="btn ghost" id="btnPasteSample">D√°n m·∫´u</button>
      <button class="btn danger" id="btnClearAll">X√≥a</button>
      <span class="badge" id="cvBadge"><span class="dot warn"></span>ƒêang t·∫£i OpenCV...</span>
      <span class="badge" id="runBadge"><span class="dot warn"></span>Ch∆∞a ch·∫°y</span>
    </div>

    <input id="fileInput" type="file" accept="image/*" multiple hidden />
  </div>

  <div class="grid">
    <div class="card">
      <h2>·∫¢nh ‚Üí OCR ‚Üí Gate</h2>
      <p class="small">
        M·∫πo: crop s√°t ph·∫ßn b·∫£ng (t·ª´ ‚ÄúƒêB‚Äù t·ªõi ‚Äú7‚Äù). Tr√°nh d√≠nh footer (Mi·ªÅn B·∫Øc/Trung/Nam) v√† header qu·∫£ng c√°o.
      </p>

      <canvas id="imgCanvas"></canvas>

      <div class="sep"></div>

      <div class="row">
        <div class="badge" id="gateBadge"><span class="dot warn"></span>Gate: ch∆∞a c√≥ d·ªØ li·ªáu</div>
        <div class="badge" id="lastParsed">DB:-- | G6:-- -- -- | G7:-- -- -- --</div>
      </div>

      <div class="sep"></div>

      <h2>S·ª≠a tay (ch·ªâ khi Gate fail)</h2>
      <div class="kv">
        <div class="small">DB (2 s·ªë)</div>
        <input id="mDB" placeholder="VD: 21" />
        <div class="small">G6 (3 s·ªë)</div>
        <input id="mG6" placeholder="VD: 01 95 93" />
        <div class="small">G7 (4 s·ªë)</div>
        <input id="mG7" placeholder="VD: 76 47 21 77" />
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn" id="btnApplyManual">√Åp manual ‚Üí th√™m d√≤ng</button>
        <button class="btn ghost" id="btnRetryLast">Th·ª≠ OCR l·∫°i ·∫£nh cu·ªëi</button>
      </div>

      <div class="sep"></div>

      <h2>Debug OCR</h2>
      <textarea id="ocrDebug" rows="7" placeholder="Debug s·∫Ω hi·ªán ·ªü ƒë√¢y..."></textarea>
    </div>

    <div class="card">
      <h2>D·ªØ li·ªáu ƒë·∫ßu v√†o (m·ªói d√≤ng = 1 ng√†y)</h2>
      <textarea id="inputData" placeholder="VD:
29/01: DB 21 | G7: 76 47 21 77 | G6: 01 95 93"></textarea>

      <div class="row" style="margin-top:10px">
        <button class="btn primary" id="btnRunFull">üöÄ Ch·∫°y FULL</button>
        <span class="badge" id="kpiBadge"><span class="dot warn"></span>KPI: ch·ªù</span>
      </div>

      <div class="sep"></div>

      <h2>K·∫æT QU·∫¢ FULL</h2>
      <pre id="output">Ch∆∞a c√≥ d·ªØ li·ªáu.</pre>
    </div>
  </div>

</div>

<script>
/* =========================
   STATE + UI
========================= */
const fileInput = document.getElementById("fileInput");
const btnUpload = document.getElementById("btnUpload");
const btnRunFull = document.getElementById("btnRunFull");
const btnPasteSample = document.getElementById("btnPasteSample");
const btnClearAll = document.getElementById("btnClearAll");
const btnApplyManual = document.getElementById("btnApplyManual");
const btnRetryLast = document.getElementById("btnRetryLast");

const cvBadge = document.getElementById("cvBadge");
const runBadge = document.getElementById("runBadge");
const gateBadge = document.getElementById("gateBadge");
const lastParsed = document.getElementById("lastParsed");
const kpiBadge = document.getElementById("kpiBadge");

const imgCanvas = document.getElementById("imgCanvas");
const ctx = imgCanvas.getContext("2d");
const ocrDebug = document.getElementById("ocrDebug");
const inputData = document.getElementById("inputData");
const output = document.getElementById("output");

const mDB = document.getElementById("mDB");
const mG6 = document.getElementById("mG6");
const mG7 = document.getElementById("mG7");

let cvReady = false;
let lastImage = null; // {img, scaleW, scaleH}
let lastScanResult = null;

function setBadge(el, type, text){
  // type: ok | bad | warn
  const dot = el.querySelector(".dot") || document.createElement("span");
  dot.className = "dot " + (type||"warn");
  if(!el.querySelector(".dot")) el.prepend(dot);
  el.lastChild && el.lastChild.nodeType===3 && el.removeChild(el.lastChild);
  el.innerHTML = `<span class="dot ${type}"></span>${text}`;
}

(function waitCV(){
  const t = setInterval(()=>{
    if(window.cv && cv.Mat){
      cvReady = true;
      clearInterval(t);
      cvBadge.innerHTML = `<span class="dot ok"></span>OpenCV OK`;
    }
  }, 80);
})();

btnUpload.onclick = () => fileInput.click();
fileInput.addEventListener("change", async e => {
  const files = [...e.target.files];
  if(!files.length) return;

  runBadge.innerHTML = `<span class="dot warn"></span>Batch ƒëang ch·∫°y...`;
  let okCount = 0, failCount = 0;

  for(let i=0;i<files.length;i++){
    runBadge.innerHTML = `<span class="dot warn"></span>·∫¢nh ${i+1}/${files.length}...`;
    const img = await loadFileToCanvas(files[i]);
    lastImage = img;
    const res = await scanFromCanvas();
    if(res && res.pass){
      okCount++;
      appendLineToInput(res.line);
    } else {
      failCount++;
    }
  }

  runBadge.innerHTML = `<span class="dot ok"></span>Batch xong: OK ${okCount} | FAIL ${failCount}`;
  if(okCount>0) runFULL();
});

btnPasteSample.onclick = () => {
  inputData.value =
`29/01: DB 21 | G7: 76 47 21 77 | G6: 01 95 93
28/01: DB 45 | G7: 03 82 85 81 | G6: 92 55 54
27/01: DB 14 | G7: 77 19 86 10 | G6: 84 17 02`;
};

btnClearAll.onclick = () => {
  inputData.value = "";
  ocrDebug.value = "";
  output.textContent = "Ch∆∞a c√≥ d·ªØ li·ªáu.";
  lastParsed.textContent = "DB:-- | G6:-- -- -- | G7:-- -- -- --";
  gateBadge.innerHTML = `<span class="dot warn"></span>Gate: ch∆∞a c√≥ d·ªØ li·ªáu`;
  kpiBadge.innerHTML = `<span class="dot warn"></span>KPI: ch·ªù`;
};

btnRunFull.onclick = () => runFULL();

btnApplyManual.onclick = () => {
  const db = (mDB.value||"").match(/\d{2}/)?.[0] || "";
  const g6 = (mG6.value||"").match(/\d{2}/g) || [];
  const g7 = (mG7.value||"").match(/\d{2}/g) || [];
  const pass = db && g6.length===3 && g7.length===4;
  if(!pass){
    gateBadge.innerHTML = `<span class="dot bad"></span>Gate manual FAIL: c·∫ßn DB=2 s·ªë, G6=3 s·ªë, G7=4 s·ªë`;
    return;
  }
  const line = `MAN: DB ${db} | G7: ${g7.slice(0,4).join(" ")} | G6: ${g6.slice(0,3).join(" ")}`;
  appendLineToInput(line);
  gateBadge.innerHTML = `<span class="dot ok"></span>Gate manual OK ‚Üí ƒë√£ th√™m d√≤ng`;
  runFULL();
};

btnRetryLast.onclick = async () => {
  if(!lastImage){ runBadge.innerHTML = `<span class="dot bad"></span>Ch∆∞a c√≥ ·∫£nh ƒë·ªÉ retry`; return; }
  runBadge.innerHTML = `<span class="dot warn"></span>ƒêang retry OCR...`;
  const res = await scanFromCanvas();
  if(res && res.pass){
    appendLineToInput(res.line);
    runBadge.innerHTML = `<span class="dot ok"></span>Retry OK ‚Üí ƒë√£ th√™m d√≤ng`;
    runFULL();
  } else {
    runBadge.innerHTML = `<span class="dot bad"></span>Retry FAIL`;
  }
};

function appendLineToInput(line){
  inputData.value += (inputData.value.trim() ? "\n" : "") + line;
}

/* =========================
   CANVAS LOAD
========================= */
function loadFileToCanvas(file){
  return new Promise(resolve=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      const maxW = Math.min(980, window.innerWidth - 28);
      const scale = Math.min(1, maxW / img.width);
      imgCanvas.width = Math.floor(img.width * scale);
      imgCanvas.height = Math.floor(img.height * scale);
      ctx.clearRect(0,0,imgCanvas.width,imgCanvas.height);
      ctx.drawImage(img, 0,0, imgCanvas.width, imgCanvas.height);
      resolve({img, scale});
    };
    img.src = url;
  });
}

/* =========================
   OCR + CV HELPERS
========================= */
function preprocess(matRGBA){
  let gray = new cv.Mat();
  cv.cvtColor(matRGBA, gray, cv.COLOR_RGBA2GRAY);

  // upscale
  let up = new cv.Mat();
  cv.resize(gray, up, new cv.Size(0,0), 3,3, cv.INTER_CUBIC);

  let blur = new cv.Mat();
  cv.GaussianBlur(up, blur, new cv.Size(3,3), 0);

  let bin = new cv.Mat();
  cv.threshold(blur, bin, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);

  gray.delete(); up.delete(); blur.delete();
  return bin;
}

function canvasFromMat(mat){
  const c = document.createElement("canvas");
  c.width = mat.cols; c.height = mat.rows;
  cv.imshow(c, mat);
  return c;
}

async function ocrText(canvas, lang="eng"){
  const res = await Tesseract.recognize(canvas, lang, {});
  return (res.data.text || "");
}

function takeLast2FromAnyDigits(text){
  const nums = (String(text).match(/\d{2,6}/g) || []);
  return nums.map(n=>n.slice(-2)).filter(x=>/^\d{2}$/.test(x));
}

function normDBLabel(t){
  return String(t).toUpperCase()
    .replace(/√ê/g,"D")
    .replace(/ƒê/g,"D")
    .replace(/D8/g,"DB")
    .replace(/O B/g,"DB")
    .replace(/OB/g,"DB");
}

/* =========================
   DB: FIND "DB" + 5 DIGITS
========================= */
async function readDB_byLabel(bodyMat){
  const H = bodyMat.rows, W = bodyMat.cols;

  const y1 = Math.floor(H * 0.14);
  const y2 = Math.floor(H * 0.62);
  const winH = Math.max(44, Math.floor(H * 0.13));
  const step = Math.max(18, Math.floor(winH * 0.35));

  const left = Math.floor(W * 0.05);
  const right = Math.floor(W * 0.05);
  const ww = Math.max(10, W - left - right);

  let best = {ok:false, text:"", five:"", y:0};

  for(let y=y1; y<=y2-winH; y+=step){
    const roi = bodyMat.roi(new cv.Rect(left, y, ww, winH));
    const bin = preprocess(roi);
    roi.delete();

    const c = canvasFromMat(bin);
    bin.delete();

    const tRaw = await ocrText(c, "eng");
    const t = normDBLabel(tRaw);

    const m = t.match(/DB[^0-9]{0,10}(\d{5})/);
    if(m && m[1]){
      best = {ok:true, text:t, five:m[1], y};
      break;
    }

    // fallback: n·∫øu kh√¥ng ch·ª©a UG v√† c√≥ 5 s·ªë
    if(!best.ok && !/UG/.test(t)){
      const m2 = t.match(/(\d{5})/);
      if(m2 && m2[1]){
        best = {ok:true, text:t, five:m2[1], y};
      }
    }
  }
  return best;
}

/* =========================
   G7: FIND RED BAND (ROW 7)
========================= */
function maskRed(matRGBA){
  let hsv = new cv.Mat();
  cv.cvtColor(matRGBA, hsv, cv.COLOR_RGBA2RGB);
  cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);

  let m1 = new cv.Mat(), m2 = new cv.Mat(), mask = new cv.Mat();

  // lower red
  let low1 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 80, 80, 0]);
  let up1  = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [10,255,255,255]);
  cv.inRange(hsv, low1, up1, m1);

  // upper red
  let low2 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [170,80,80,0]);
  let up2  = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180,255,255,255]);
  cv.inRange(hsv, low2, up2, m2);

  cv.bitwise_or(m1, m2, mask);

  // clean
  let k = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(5,5));
  cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, k);

  hsv.delete(); m1.delete(); m2.delete();
  low1.delete(); up1.delete(); low2.delete(); up2.delete();
  k.delete();
  return mask;
}

function findBottomRedBand(mask){
  let contours = new cv.MatVector(), hierarchy = new cv.Mat();
  cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  let best = null;
  for(let i=0;i<contours.size();i++){
    const c = contours.get(i);
    const r = cv.boundingRect(c);
    c.delete();

    // l·ªçc nhi·ªÖu
    if(r.width < mask.cols*0.35) continue;
    if(r.height < 10) continue;

    // ∆∞u ti√™n v√πng th·∫•p + r·ªông
    const score = (r.y + r.height) + r.width*0.25;
    if(!best || score > best.score){
      best = {rect:r, score};
    }
  }
  contours.delete(); hierarchy.delete();
  return best ? best.rect : null;
}

/* =========================
   CORE SCAN: DB + G7 + G6
========================= */
async function scanFromCanvas(){
  if(!cvReady){
    runBadge.innerHTML = `<span class="dot bad"></span>OpenCV ch∆∞a s·∫µn s√†ng`;
    return null;
  }

  // ƒë·ªçc canvas th√†nh mat
  let src = cv.imread(imgCanvas);

  // body crop: c·∫Øt nh·∫π header/footer (t∆∞∆°ng ƒë·ªëi)
  const H = src.rows, W = src.cols;
  const topCut = Math.floor(H * 0.06);
  const botCut = Math.floor(H * 0.08);
  const bodyH = Math.max(10, H - topCut - botCut);
  const body = src.roi(new cv.Rect(0, topCut, W, bodyH));

  // 1) DB theo nh√£n
  const dbHit = await readDB_byLabel(body);
  const DB = dbHit.ok ? dbHit.five.slice(-2) : "";

  // 2) G7 theo ƒë·ªè
  const red = maskRed(body);
  const band = findBottomRedBand(red);
  red.delete();

  let G7 = [], G6 = [];
  let dbg = "";

  if(band){
    const pad = 10;
    const x = Math.max(0, band.x - pad);
    const y = Math.max(0, band.y - pad);
    const w = Math.min(body.cols - x, band.width + pad*2);
    const h = Math.min(body.rows - y, band.height + pad*2);

    // G7 roi
    const g7Roi = body.roi(new cv.Rect(x, y, w, h));
    const g7Bin = preprocess(g7Roi);
    g7Roi.delete();
    const g7C = canvasFromMat(g7Bin);
    g7Bin.delete();

    const g7Txt = await ocrText(g7C, "eng");
    G7 = takeLast2FromAnyDigits(g7Txt).slice(0,4);

    // G6: l·∫•y v√πng TR√äN G7, ƒë·ªß cao v√† c√≥ GAP ƒë·ªÉ kh√¥ng d√≠nh ƒë·ªè
    const g6Height = Math.max(48, Math.floor(body.rows * 0.16));
    const g6Gap = 22; // gap c·ª©ng ƒë·ªÉ tr√°nh d√≠nh band ƒë·ªè
    const g6Top = Math.max(0, y - g6Height - g6Gap);

    const g6Roi = body.roi(new cv.Rect(x, g6Top, w, Math.min(g6Height, body.rows - g6Top)));
    const g6Bin = preprocess(g6Roi);
    g6Roi.delete();
    const g6C = canvasFromMat(g6Bin);
    g6Bin.delete();

    const g6Txt = await ocrText(g6C, "eng");

    // ∆∞u ti√™n 3 s·ªë 3 ch·ªØ s·ªë (G6 mi·ªÅn b·∫Øc)
    const t3 = (String(g6Txt).match(/\d{3}/g) || []).slice(0,3);
    if(t3.length === 3){
      G6 = t3.map(s=>s.slice(-2));
    } else {
      // fallback: c·∫∑p 2 s·ªë
      G6 = takeLast2FromAnyDigits(g6Txt).slice(0,3);
    }

    dbg += `[DB_LABEL_SCAN]\n${dbHit.text}\n[DB_5DIG]\n${dbHit.five || "(none)"}\n\n`;
    dbg += `[G7_BAND_OCR]\n${g7Txt}\n[G6_ZONE_OCR]\n${g6Txt}\n`;
  } else {
    dbg += `[DB_LABEL_SCAN]\n${dbHit.text}\n[DB_5DIG]\n${dbHit.five || "(none)"}\n\n`;
    dbg += `[G7_BAND] (none)\n`;
  }

  // cleanup mats
  body.delete(); src.delete();

  // gate
  const pass = !!DB && G7.length===4 && G6.length===3;

  const parsedStr = `DB:${DB||"--"} | G6:${(G6.join(" ")||"--")} | G7:${(G7.join(" ")||"--")}`;
  lastParsed.textContent = parsedStr;

  if(pass){
    gateBadge.innerHTML = `<span class="dot ok"></span>Gate PASS ‚úÖ (ƒë·ªï d·ªØ li·ªáu)`;
  } else {
    gateBadge.innerHTML = `<span class="dot bad"></span>Gate FAIL ‚ùå (kh√¥ng ƒë·ªï d·ªØ li·ªáu)`;
  }

  ocrDebug.value = dbg;
  lastScanResult = {DB, G6, G7, pass, dbg};

  // line normalize
  const line = `AUTO: DB ${DB} | G7: ${G7.join(" ")} | G6: ${G6.join(" ")}`;
  return {DB, G6, G7, pass, line, dbg};
}

/* =========================
   FULL ENGINE (t·∫°m: HOT + KPI)
   B·∫°n mu·ªën ‚ÄúPascal/Pha/Tr·ª•c/Anti-b·∫´y‚Äù th√¨ m√¨nh s·∫Ω r√°p ti·∫øp v√†o ƒë√¢y,
   nh∆∞ng hi·ªán ∆∞u ti√™n ƒê·∫¶U V√ÄO ƒê√öNG + GATE C·ª®NG theo y√™u c·∫ßu c·ªßa b·∫°n.
========================= */
function runFULL(){
  const lines = inputData.value.trim().split("\n").filter(Boolean);
  if(lines.length < 3){
    kpiBadge.innerHTML = `<span class="dot bad"></span>KPI: c·∫ßn ‚â•3 ng√†y`;
    output.textContent = "‚ùå C·∫ßn ‚â•3 ng√†y d·ªØ li·ªáu.";
    return;
  }

  // t√°ch to√†n b·ªô c·∫∑p 2 s·ªë
  const freq = {};
  const dbFreq = {};
  lines.forEach(line=>{
    const db = (line.match(/DB\s+(\d{2})/i)||[])[1];
    if(db) dbFreq[db] = (dbFreq[db]||0)+1;

    const nums = (line.match(/\b\d{2}\b/g)||[]);
    nums.forEach(n => freq[n] = (freq[n]||0)+1);
  });

  const sorted = Object.entries(freq).sort((a,b)=>b[1]-a[1]);
  const topHot = sorted.slice(0,14);

  // g·ª£i √Ω ch·ªët (demo): ∆∞u ti√™n s·ªë xu·∫•t hi·ªán nhi·ªÅu + c√≥ m·∫∑t trong DB g·∫ßn ƒë√¢y
  const dbSorted = Object.entries(dbFreq).sort((a,b)=>b[1]-a[1]);
  const main = (dbSorted[0]?.[0]) || (sorted[0]?.[0]) || "--";
  const sub  = (dbSorted[1]?.[0]) || (sorted[1]?.[0]) || "--";

  kpiBadge.innerHTML = `<span class="dot ok"></span>KPI: T·ªïng ${lines.length} ng√†y ‚Ä¢ TopHot ${topHot.length}`;

  output.textContent =
`T·ªïng ng√†y: ${lines.length}

TOP HOT:
${topHot.map(x=>`${x[0]} ‚Üí ${x[1]}`).join("\n")}

TOP ƒêB (2 s·ªë):
${dbSorted.slice(0,8).map(x=>`${x[0]} ‚Üí ${x[1]}`).join("\n") || "(ch∆∞a t√°ch ƒë∆∞·ª£c DB)"}

CH·ªêT G·ª¢I √ù (demo th·ªëng k√™):
üéØ Ch√≠nh: ${main}
üõ° Ph·ª•: ${sub}

* Tool th·ªëng k√™ h·ªó tr·ª£, kh√¥ng ƒë·∫£m b·∫£o tr√∫ng.
* Gate ƒëang ∆∞u ti√™n ‚Äúƒë·∫ßu v√†o ƒë√∫ng‚Äù: DB theo nh√£n + 5 s·ªë; G7 theo ƒë·ªè; G6 theo 3 s·ªë 3 ch·ªØ s·ªë ngay tr√™n G7.`;
}

/* =========================
   OPTIONAL: auto scan on first click canvas (for quick test)
========================= */
imgCanvas.addEventListener("click", async ()=>{
  if(!lastImage) return;
  runBadge.innerHTML = `<span class="dot warn"></span>ƒêang OCR ·∫£nh cu·ªëi...`;
  const res = await scanFromCanvas();
  if(res && res.pass){
    runBadge.innerHTML = `<span class="dot ok"></span>OCR OK (Gate pass)`;
  } else {
    runBadge.innerHTML = `<span class="dot bad"></span>OCR FAIL (Gate fail)`;
  }
});
</script>
</body>
</html>
