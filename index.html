<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>B√πi H√†o ‚Äî Lotto ULTRA PRO (OCR Batch)</title>

  <style>
    :root{
      --b:#0f172a; --m:#64748b;
      --bd:rgba(15,23,42,.10);
      --card:rgba(255,255,255,.86);
      --ok:#0a7; --warn:#c80; --bad:#c22;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      color:var(--b);
      background:
        radial-gradient(1200px 600px at 18% -10%, #e8f3ff 0%, rgba(255,255,255,0) 55%),
        radial-gradient(900px 500px at 110% 10%, #fff0ec 0%, rgba(255,255,255,0) 60%),
        radial-gradient(900px 500px at 40% 120%, #f1ffe9 0%, rgba(255,255,255,0) 55%),
        linear-gradient(180deg, #ffffff 0%, #fbfbfb 100%);
    }
    .wrap{max-width:1180px; margin:0 auto; padding:16px;}
    .topbar{
      display:flex; align-items:flex-start; justify-content:space-between; gap:12px;
      padding:14px; border:1px solid var(--bd); border-radius:18px;
      background:rgba(255,255,255,.80);
      backdrop-filter: blur(8px);
      box-shadow: 0 12px 30px rgba(2,8,23,.06);
      margin-bottom:12px;
    }
    .brand .title{font-weight:900; letter-spacing:.2px; font-size:18px;}
    .brand .badge{
      display:inline-flex; align-items:center; gap:8px; margin-top:6px;
      padding:6px 10px; border-radius:999px; font-size:12px;
      border:1px solid rgba(15,23,42,.10);
      background:rgba(255,255,255,.70);
      color:rgba(15,23,42,.72);
    }
    .muted{color:var(--m); font-size:13px; line-height:1.45;}
    .card{
      border:1px solid var(--bd);
      border-radius:18px;
      padding:14px;
      margin:12px 0;
      background:var(--card);
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 28px rgba(2,8,23,.06);
    }
    h2{font-size:14.5px; margin:0 0 8px;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .between{justify-content:space-between;}
    .pill{
      border:1px solid rgba(15,23,42,.10);
      border-radius:999px;
      padding:6px 10px;
      font-size:12.5px;
      background:rgba(255,255,255,.65);
    }
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;}
    textarea{
      width:100%; min-height:170px;
      border:1px solid rgba(15,23,42,.12);
      border-radius:16px;
      padding:12px;
      font-size:14px;
      resize:vertical;
      background:rgba(255,255,255,.92);
      outline:none;
    }
    input,select{
      border:1px solid rgba(15,23,42,.12);
      border-radius:14px;
      padding:9px 10px;
      font-size:13px;
      background:rgba(255,255,255,.92);
      outline:none;
    }
    button{
      border:0;
      border-radius:14px;
      padding:10px 14px;
      cursor:pointer;
      font-weight:900;
      background:#0f172a;
      color:#fff;
      box-shadow: 0 10px 20px rgba(15,23,42,.16);
    }
    button.secondary{
      background:rgba(255,255,255,.92);
      color:#0f172a;
      border:1px solid rgba(15,23,42,.12);
      box-shadow:none;
      font-weight:800;
    }
    button:disabled{opacity:.55; cursor:not-allowed}
    .grid{display:grid; grid-template-columns:1fr; gap:12px;}
    @media (min-width: 980px){ .grid{grid-template-columns:1fr 1fr;} }

    .canvasWrap{
      border:1px solid rgba(15,23,42,.12);
      border-radius:16px;
      background:rgba(255,255,255,.92);
      overflow:hidden;
    }
    #imgCanvas{width:100%; height:auto; display:block; touch-action:none;}

    table{width:100%; border-collapse:collapse;}
    th,td{border-bottom:1px solid rgba(15,23,42,.08); padding:8px 6px; font-size:12.8px; text-align:left;}
    th{background:rgba(255,255,255,.92); position:sticky; top:0; z-index:1; font-weight:900;}

    .tag{
      display:inline-block;
      padding:4px 10px;
      border-radius:999px;
      font-size:12px;
      border:1px solid rgba(15,23,42,.12);
      background:rgba(255,255,255,.72);
      font-weight:900;
    }
    .tag.ok{border-color:rgba(0,170,120,.25); color:var(--ok); background:rgba(0,170,120,.06);}
    .tag.warn{border-color:rgba(204,136,0,.25); color:var(--warn); background:rgba(204,136,0,.06);}
    .tag.bad{border-color:rgba(204,34,34,.25); color:var(--bad); background:rgba(204,34,34,.06);}

    .kpi{display:flex; gap:10px; flex-wrap:wrap;}
    .kpi .box{
      flex:1; min-width:200px;
      border:1px solid rgba(15,23,42,.10);
      border-radius:16px;
      padding:10px;
      background:rgba(255,255,255,.75);
    }
    .big{font-size:20px; font-weight:950;}
    .small{font-size:12.5px; color:var(--m);}
    .sep{height:1px; background:rgba(15,23,42,.08); margin:10px 0;}
    .note{font-size:12px; color:var(--m);}
    .good{font-weight:900;}
  </style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="brand">
      <div class="title">B√πi H√†o ‚Äî Lotto ULTRA PRO</div>
      <div class="badge">WEB ‚Ä¢ AI SCAN ‚Ä¢ BATCH ‚Ä¢ PASCAL ‚Ä¢ PHA ‚Ä¢ TR·ª§C ‚Ä¢ ANTI-B·∫™Y</div>
      <div class="muted" style="margin-top:8px;">
        Upload nhi·ªÅu ·∫£nh (m·ªói ·∫£nh = 1 ng√†y) ‚Üí AI t·ª± b√≥c DB/G7/G6 ‚Üí t·ª± ch·∫°y FULL.
        <b>*Tool th·ªëng k√™ h·ªó tr·ª£ ph√¢n t√≠ch. Kh√¥ng ƒë·∫£m b·∫£o k·∫øt qu·∫£.</b>
      </div>
    </div>
    <div class="row">
      <button class="secondary" id="btnSample">D√°n m·∫´u</button>
      <button class="secondary" id="btnClear">X√≥a</button>
    </div>
  </div>

  <div class="card">
    <h2>üì∑ AI Scan PRO (App KQXS Mi·ªÅn B·∫Øc) ‚Äî Upload nhi·ªÅu ·∫£nh</h2>
    <div class="muted">
      ·∫¢nh m·∫´u c·ªßa b·∫°n l√† b·∫£ng MB c√≥ h√†ng: <b>ƒêB, 1, 2, 3, 4, 5, 6, 7</b>.
      AI s·∫Ω l·∫•y: <b>DB = 2 s·ªë cu·ªëi gi·∫£i ƒêB</b>, <b>G6 = 3 s·ªë</b>, <b>G7 = 4 s·ªë</b>.
    </div>

    <div class="row" style="margin-top:10px;">
      <button class="secondary" id="btnCamera">üì∑ Camera</button>
      <button class="secondary" id="btnUpload">üñºÔ∏è T·∫£i t·ª´ t·ªáp (multi)</button>
      <span class="pill" id="ocrStatus">Ch∆∞a c√≥ ·∫£nh.</span>
      <span class="pill">Auto: OCR ‚Üí t·∫°o d√≤ng chu·∫©n ‚Üí ch·∫°y FULL</span>
    </div>

    <input id="fileCamera" type="file" accept="image/*" capture="environment" hidden />
    <input id="fileUpload" type="file" accept="image/*" multiple hidden />

    <div class="grid" style="margin-top:12px;">
      <div>
        <div class="muted good">Preview (k√©o ƒë·ªÉ crop n·∫øu c·∫ßn)</div>
        <div class="canvasWrap" style="margin-top:8px;">
          <canvas id="imgCanvas"></canvas>
        </div>
        <div class="note" style="margin-top:8px;">
          Tip: n·∫øu OCR h·ª•t, crop s√°t ph·∫ßn t·ª´ ‚ÄúƒêB‚Äù ƒë·∫øn ‚Äú7‚Äù.
        </div>
      </div>

      <div>
        <div class="muted good">Text OCR (ƒë·ªÉ ki·ªÉm tra)</div>
        <textarea id="ocrText" placeholder="OCR text s·∫Ω hi·ªán ·ªü ƒë√¢y..."></textarea>
        <div class="row" style="margin-top:10px;">
          <span class="pill">B√≥c 00‚Äì99:</span>
          <span class="mono" id="ocrPairs">--</span>
        </div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="row between">
      <div class="row">
        <span class="pill">Input: KQXS (m·ªói d√≤ng = 1 ng√†y)</span>
        <span class="pill">Output: Pascal ‚Ä¢ Pha ‚Ä¢ Tr·ª•c ‚Ä¢ Ch·ªët</span>
      </div>
      <div class="row">
        <button id="btnRun">Ch·∫°y FULL</button>
      </div>
    </div>

    <textarea id="input" placeholder="Sau khi upload ·∫£nh, tool s·∫Ω t·ª± ƒë·ªï v√†o ƒë√¢y.
V√≠ d·ª•:
29/01: DB 14 | G7: 81 87 60 32 | G6: 06 00 71
28/01: DB 59 | G7: 21 41 02 14 | G6: 03 63 87"></textarea>

    <div class="row" style="margin-top:10px;">
      <span class="pill">C·ª≠a s·ªï ng√†y:</span>
      <input id="windowDays" type="number" min="5" max="120" value="30" style="width:90px;">
      <span class="pill">Top hi·ªÉn th·ªã:</span>
      <input id="topN" type="number" min="5" max="40" value="15" style="width:90px;">
      <span class="pill">Pascal t·∫ßng:</span>
      <select id="pascalDepth">
        <option value="2">2 t·∫ßng</option>
        <option value="3" selected>3 t·∫ßng</option>
        <option value="4">4 t·∫ßng</option>
      </select>
      <span class="pill">Tr·ªçng s·ªë (hot/gan/pascal):</span>
      <input id="wHot" type="number" min="0" max="5" step="0.5" value="2" style="width:75px;">
      <input id="wGan" type="number" min="0" max="5" step="0.5" value="1.5" style="width:75px;">
      <input id="wPas" type="number" min="0" max="5" step="0.5" value="2" style="width:75px;">
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h2>KPI nhanh</h2>
      <div class="kpi" id="kpi"></div>
      <div class="sep"></div>
      <div id="phaseBox" class="muted">Ch∆∞a c√≥ d·ªØ li·ªáu.</div>
    </div>

    <div class="card">
      <h2>CH·ªêT (FULL)</h2>
      <div id="pickBox" class="muted">Ch∆∞a c√≥ d·ªØ li·ªáu.</div>
      <div class="sep"></div>
      <div id="antiBox" class="muted">Anti-b·∫´y s·∫Ω hi·ªán t·∫°i ƒë√¢y.</div>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h2>Pascal (2 ch·ªØ s·ªë) ‚Äî tr√πng t·∫ßng</h2>
      <div class="muted">Seed Pascal: ∆∞u ti√™n DB xx theo t·ª´ng ng√†y.</div>
      <div class="sep"></div>
      <div id="pascalBox" class="mono muted"></div>
    </div>

    <div class="card">
      <h2>Tr·ª•c (a‚Üîb) & ƒê·∫ßu/ƒêu√¥i</h2>
      <div id="axisBox" class="muted"></div>
      <div class="sep"></div>
      <div class="grid">
        <div>
          <div class="muted good">ƒê·∫ßu (0‚Äì9)</div>
          <div id="heads" class="mono muted"></div>
        </div>
        <div>
          <div class="muted good">ƒêu√¥i (0‚Äì9)</div>
          <div id="tails" class="mono muted"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h2>Hot pairs</h2>
      <div style="max-height:340px; overflow:auto;">
        <table>
          <thead><tr><th>#</th><th>C·∫∑p</th><th>L·∫ßn</th><th>Gan</th><th>ƒêi·ªÉm</th><th>L√Ω do</th></tr></thead>
          <tbody id="tblHot"></tbody>
        </table>
      </div>
    </div>

    <div class="card">
      <h2>Gan pairs</h2>
      <div style="max-height:340px; overflow:auto;">
        <table>
          <thead><tr><th>#</th><th>C·∫∑p</th><th>Gan (ng√†y)</th><th>L·∫ßn</th><th>ƒêi·ªÉm</th><th>L√Ω do</th></tr></thead>
          <tbody id="tblGan"></tbody>
        </table>
      </div>
    </div>
  </div>

  <div class="card muted" style="text-align:center;">
    ¬© B√πi H√†o ‚Äî Lotto ULTRA PRO ‚Ä¢ Web AI Scan Batch
  </div>
</div>

<script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // UI
  const inputEl = $("input");
  const kpiEl = $("kpi");
  const phaseBox = $("phaseBox");
  const pickBox = $("pickBox");
  const antiBox = $("antiBox");
  const pascalBox = $("pascalBox");
  const axisBox = $("axisBox");
  const headsEl = $("heads");
  const tailsEl = $("tails");
  const tblHot = $("tblHot");
  const tblGan = $("tblGan");

  // OCR UI
  const btnCamera = $("btnCamera");
  const btnUpload = $("btnUpload");
  const fileCamera = $("fileCamera");
  const fileUpload = $("fileUpload");
  const imgCanvas = $("imgCanvas");
  const ctxImg = imgCanvas.getContext("2d");
  const ocrStatus = $("ocrStatus");
  const ocrText = $("ocrText");
  const ocrPairs = $("ocrPairs");

  function setStatus(msg){ ocrStatus.textContent = msg; }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c])); }
  function clampInt(n, min, max){ n = Number.isFinite(n) ? n : min; return Math.max(min, Math.min(max, Math.floor(n))); }
  function clampNum(n, min, max){ n = Number.isFinite(n) ? n : min; return Math.max(min, Math.min(max, n)); }
  function round2(x){ return Math.round(x*100)/100; }

  // sample / clear
  $("btnSample").addEventListener("click", () => {
    inputEl.value =
`29/01: DB 14 | G7: 81 87 60 32 | G6: 06 00 71
28/01: DB 59 | G7: 21 41 02 14 | G6: 03 63 87
27/01: DB 63 | G7: 03 14 59 87 | G6: 21 02 14`;
  });

  $("btnClear").addEventListener("click", () => {
    inputEl.value = "";
    renderEmpty();
    setStatus("Ch∆∞a c√≥ ·∫£nh.");
    clearCanvas();
    ocrText.value = "";
    ocrPairs.textContent = "--";
  });

  $("btnRun").addEventListener("click", () => runFull());
  window.runFull = runFull;

  function renderEmpty(){
    kpiEl.innerHTML = "";
    phaseBox.textContent = "Ch∆∞a c√≥ d·ªØ li·ªáu.";
    pickBox.textContent = "Ch∆∞a c√≥ d·ªØ li·ªáu.";
    antiBox.textContent = "Anti-b·∫´y s·∫Ω hi·ªán t·∫°i ƒë√¢y.";
    pascalBox.textContent = "";
    axisBox.textContent = "";
    headsEl.textContent = "";
    tailsEl.textContent = "";
    tblHot.innerHTML = "";
    tblGan.innerHTML = "";
  }

  // ===== Data parse =====
  function parseDays(raw){
    const lines = raw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    return lines.map((line, idx) => {
      const pairs = (line.match(/\b\d{2}\b/g) || []);
      const uniqPairs = Array.from(new Set(pairs));

      let db = null;
      const m = line.match(/\bDB\b[^0-9]*?(\d{2})\b/i);
      if (m) db = m[1];

      const seed = db ?? (pairs.length ? pairs[pairs.length - 1] : null);
      return { dayIndex: idx, line, pairs: uniqPairs, db, seed };
    });
  }

  function countStats(days){
    const freq = new Map();
    const lastSeen = new Map();
    const headCnt = Array(10).fill(0);
    const tailCnt = Array(10).fill(0);
    const axisCnt = new Map();

    days.forEach((d, dayIndex) => {
      d.pairs.forEach(p => {
        freq.set(p, (freq.get(p) || 0) + 1);
        if (!lastSeen.has(p)) lastSeen.set(p, dayIndex);

        const h = +p[0], t = +p[1];
        headCnt[h]++; tailCnt[t]++;

        const a = Math.min(h,t), b = Math.max(h,t);
        const key = `${a}-${b}`;
        axisCnt.set(key, (axisCnt.get(key) || 0) + 1);
      });
    });

    return { freq, lastSeen, headCnt, tailCnt, axisCnt };
  }

  function sortMapDesc(map){
    return Array.from(map.entries()).sort((a,b) => b[1] - a[1]);
  }

  // ===== Pascal =====
  function buildPascal(days, depth){
    const seeds = days.map(d => d.seed).filter(Boolean).slice(0, Math.max(6, depth + 3));
    if (seeds.length < 4) return { ok:false, msg:"Thi·∫øu seed Pascal (c·∫ßn √≠t nh·∫•t 4 ng√†y c√≥ DB)." };

    const digits = seeds.map(s => [ +s[0], +s[1] ]);
    const stream = [];
    digits.forEach(([h,t]) => { stream.push(h,t); });

    let layer = stream.slice();
    const layers = [{ name:"L0", arr: layer.slice(0, 20) }];
    for (let k=1;k<=depth;k++){
      const next = [];
      for (let i=0;i<layer.length-1;i++){
        next.push((layer[i] + layer[i+1]) % 10);
      }
      layer = next;
      layers.push({ name:`L${k}`, arr: layer.slice(0, 20) });
    }

    const digitLayerCount = new Map();
    layers.forEach((L, idx) => {
      if (idx === 0) return;
      const set = new Set(L.arr);
      set.forEach(d => digitLayerCount.set(d, (digitLayerCount.get(d)||0)+1));
    });

    const digitRank = Array.from(digitLayerCount.entries()).sort((a,b)=>b[1]-a[1]);
    const topDigits = digitRank.slice(0, 6).map(x=>x[0]);

    const candidates = new Map();
    for (let i=0;i<topDigits.length;i++){
      for (let j=0;j<topDigits.length;j++){
        const h = topDigits[i], t = topDigits[j];
        const pair = `${h}${t}`;
        const score = (digitLayerCount.get(h)||0) + (digitLayerCount.get(t)||0);
        candidates.set(pair, Math.max(candidates.get(pair)||0, score));
      }
    }

    return { ok:true, seeds, layers, digitRank, candidates };
  }

  // ===== Phase (MASTER+++) heuristic =====
  function variance(arr){
    const n = arr.length;
    const mean = arr.reduce((a,b)=>a+b,0)/n;
    const v = arr.reduce((s,x)=>s+(x-mean)*(x-mean),0)/n;
    return v;
  }

  function inferPhase(days, stats){
    const dbs = days.map(d=>d.db).filter(Boolean).slice(0, 14);
    const uniqDB = new Set(dbs);
    const hotPairs = sortMapDesc(stats.freq).slice(0, 5);
    const topHotCount = hotPairs[0]?.[1] || 0;

    const headVar = variance(stats.headCnt);
    const tailVar = variance(stats.tailCnt);

    const repRate = topHotCount / Math.max(1, days.length);
    const uniqRate = uniqDB.size / Math.max(1, dbs.length);

    const last3 = days.slice(0,3);
    let ganHits = 0;
    last3.forEach(d=>{
      d.pairs.forEach(p=>{
        const g = stats.lastSeen.get(p);
        if (g !== undefined && g >= Math.min(10, days.length-1)) ganHits++;
      });
    });

    let phase = "CH·∫†Y";
    let tag = "ok";
    let reason = [];

    if (days.length < 10) reason.push("D·ªØ li·ªáu √≠t ‚Üí pha ch·ªâ tham kh·∫£o.");

    if (uniqRate >= 0.75 && repRate < 0.20) { phase = "M·ªû"; tag="ok"; reason.push("DB ƒëa d·∫°ng, ƒë·ªô l·∫∑p th·∫•p."); }
    if (repRate >= 0.35 || headVar < 2.0 || tailVar < 2.0) { phase = "X·∫¢"; tag="warn"; reason.push("ƒê·ªô l·∫∑p cao / ƒë·∫ßu-ƒëu√¥i d·ªìn c·ª•m."); }
    if (ganHits >= 6 && repRate >= 0.25) { phase = "H·ªíI"; tag="ok"; reason.push("Gan-hit tƒÉng trong 3 ng√†y g·∫ßn ‚Üí d·∫•u h·ªìi."); }
    if (repRate >= 0.45) { phase="X·∫¢"; tag="bad"; reason.push("Top l·∫∑p qu√° m·∫°nh ‚Üí d·ªÖ nhi·ªÖu/b·∫´y."); }

    return { phase, tag, uniqRate: round2(uniqRate), repRate: round2(repRate), ganHits, reason };
  }

  // ===== Score / Picks =====
  function scorePairs(days, stats, pas){
    const window = days.length;
    const wHot = clampNum(+$("wHot").value, 0, 5);
    const wGan = clampNum(+$("wGan").value, 0, 5);
    const wPas = clampNum(+$("wPas").value, 0, 5);

    const scored = [];
    const axisRank = sortMapDesc(stats.axisCnt);
    const axisTop = new Set(axisRank.slice(0, 8).map(x=>x[0]));

    const universe = new Set([...stats.freq.keys(), ...(pas?.candidates ? pas.candidates.keys() : [])]);

    universe.forEach(pair => {
      const hot = stats.freq.get(pair) || 0;
      const gan = stats.lastSeen.has(pair) ? stats.lastSeen.get(pair) : window;
      const pasScore = pas?.candidates?.get(pair) || 0;

      const h = +pair[0], t = +pair[1];
      const a = Math.min(h,t), b = Math.max(h,t);
      const axisKey = `${a}-${b}`;
      const axis = stats.axisCnt.get(axisKey) || 0;

      const hotN = hot / Math.max(1, window);
      const ganN = gan / Math.max(1, window);
      const pasN = pasScore / 10;
      const axisN = axis / Math.max(1, window);

      let penalty = 0;
      if (gan === 0 && hot >= Math.max(3, Math.floor(window*0.18))) penalty += 0.25;
      if (hotN > 0.35) penalty += 0.20;

      const score = (wHot*hotN) + (wGan*ganN) + (wPas*pasN) + (0.8*axisN) - penalty;

      const why = [];
      if (hot) why.push(`hot:${hot}`);
      why.push(`gan:${gan}`);
      if (pasScore) why.push(`pas:${pasScore}`);
      if (axisTop.has(axisKey)) why.push(`tr·ª•c:${axisKey}`);
      if (penalty>0) why.push(`-b·∫´y:${round2(penalty)}`);

      scored.push({ pair, hot, gan, pas: pasScore, axis: axisKey, score, why: why.join(" ‚Ä¢ ") });
    });

    scored.sort((a,b)=>b.score-a.score);
    return scored;
  }

  function pickFinal(scored, phaseInfo){
    const phase = phaseInfo.phase;
    const isTooSpam = (x) => (x.gan === 0 && x.hot >= 3);

    let main = scored.find(x => phase==="X·∫¢" ? !isTooSpam(x) : true) || scored[0];
    if (!main) return null;

    const mh = main.pair[0], mt = main.pair[1];
    let side = scored.find(x => x.pair !== main.pair && (x.pair[0] !== mh || x.pair[1] !== mt)) || scored[1] || main;

    const top60 = scored.slice(0, 60);
    let hedge = top60.sort((a,b)=>b.gan-a.gan)[0] || side;

    return { main, side, hedge };
  }

  function antiWarnings(days, stats, phaseInfo, picks){
    const warn = [];
    if (days.length < 10) warn.push({t:"warn", m:"D·ªØ li·ªáu < 10 ng√†y: k·∫øt lu·∫≠n d·ªÖ l·ªách. N√™n tƒÉng c·ª≠a s·ªï 20‚Äì30 ng√†y."});

    const maxHead = Math.max(...stats.headCnt), maxTail = Math.max(...stats.tailCnt);
    const sum = stats.headCnt.reduce((a,b)=>a+b,0);
    if (sum>0){
      if (maxHead/sum > 0.20) warn.push({t:"warn", m:"ƒê·∫¶U b·ªã d·ªìn c·ª•m m·∫°nh ‚Üí d·ªÖ nhi·ªÖu (b·∫´y c·ª•m)."});
      if (maxTail/sum > 0.20) warn.push({t:"warn", m:"ƒêU√îI b·ªã d·ªìn c·ª•m m·∫°nh ‚Üí d·ªÖ nhi·ªÖu (b·∫´y c·ª•m)."});
    }

    const hotTop = sortMapDesc(stats.freq).slice(0, 1)[0];
    if (hotTop && hotTop[1] >= Math.max(4, Math.floor(days.length*0.22))){
      warn.push({t:"bad", m:`C·∫∑p top (${hotTop[0]}) l·∫∑p qu√° d√†y ‚Üí d·ªÖ b·∫´y l·∫∑p. H·∫°n ch·∫ø ‚Äúƒëu·ªïi‚Äù ƒë√∫ng 1 s·ªë.`});
    }

    if (phaseInfo.phase === "X·∫¢") warn.push({t:"warn", m:"Pha X·∫¢: ∆∞u ti√™n s·ªë c√¢n b·∫±ng, tr√°nh s·ªë v·ª´a ra h√¥m nay."});
    if (phaseInfo.phase === "M·ªû") warn.push({t:"ok", m:"Pha M·ªû: s·ªë m·ªõi/gan v·ª´a ph·∫£i d·ªÖ c√≥ c·ª≠a."});
    if (phaseInfo.phase === "H·ªíI") warn.push({t:"ok", m:"Pha H·ªíI: ∆∞u ti√™n s·ªë gan c√≥ x√°c nh·∫≠n Pascal/tr·ª•c."});

    if (picks?.main?.gan === 0 && picks?.main?.hot >= 3) warn.push({t:"warn", m:"S·ªë CH√çNH v·ª´a ra s√°t + hot ‚Üí n·∫øu th·∫•y nhi·ªÖu, c√¢n nh·∫Øc chuy·ªÉn sang s·ªë PH·ª§."});
    return warn;
  }

  function runFull(){
    const raw = inputEl.value || "";
    const allDays = parseDays(raw);

    const windowDays = clampInt(+$("windowDays").value, 5, 120);
    const topN = clampInt(+$("topN").value, 5, 40);
    const depth = clampInt(+$("pascalDepth").value, 2, 4);

    const days = allDays.slice(0, windowDays);
    if (days.length < 5){
      renderEmpty();
      phaseBox.innerHTML = `<span class="tag bad">Thi·∫øu d·ªØ li·ªáu</span> C·∫ßn √≠t nh·∫•t 5 d√≤ng (5 ng√†y).`;
      return;
    }

    const stats = countStats(days);
    const pas = buildPascal(days, depth);
    const phaseInfo = inferPhase(days, stats);
    const scored = scorePairs(days, stats, pas.ok ? pas : null);
    const picks = pickFinal(scored, phaseInfo);
    const warnings = antiWarnings(days, stats, phaseInfo, picks);

    const totalPairs = stats.freq.size;
    const hotTop = sortMapDesc(stats.freq)[0] || ["--", 0];
    const ganTop = Array.from(stats.lastSeen.entries()).map(([p,g])=>({p,g,hot:stats.freq.get(p)||0}))
      .sort((a,b)=>b.g-a.g)[0] || {p:"--", g:0, hot:0};

    kpiEl.innerHTML = `
      <div class="box"><div class="small">S·ªë ng√†y ph√¢n t√≠ch</div><div class="big">${days.length}</div><div class="small">C·ª≠a s·ªï: ${windowDays} ng√†y</div></div>
      <div class="box"><div class="small">T·ªïng c·∫∑p unique</div><div class="big">${totalPairs}</div><div class="small">B√≥c t·ª´ DB/G6/G7</div></div>
      <div class="box"><div class="small">Hot #1</div><div class="big mono">${hotTop[0]}</div><div class="small">${hotTop[1]} l·∫ßn</div></div>
      <div class="box"><div class="small">Gan #1</div><div class="big mono">${ganTop.p}</div><div class="small">gan ${ganTop.g} ng√†y ‚Ä¢ hot ${ganTop.hot}</div></div>
    `;

    phaseBox.innerHTML = `
      <div class="row">
        <span class="tag ${phaseInfo.tag}">PHA: ${phaseInfo.phase}</span>
        <span class="pill">DB ƒëa d·∫°ng: ${phaseInfo.uniqRate}</span>
        <span class="pill">ƒê·ªô l·∫∑p: ${phaseInfo.repRate}</span>
        <span class="pill">Gan-hit 3 ng√†y: ${phaseInfo.ganHits}</span>
      </div>
      <div class="muted" style="margin-top:6px;">${escapeHtml(phaseInfo.reason.join(" ")) || "‚Äî"}</div>
    `;

    if (!pas.ok){
      pascalBox.innerHTML = `<span class="tag bad">Pascal</span> ${escapeHtml(pas.msg)}`;
    } else {
      const seedStr = pas.seeds.slice(0, 10).join(" ");
      const layerStr = pas.layers.map(L => `${L.name}: [${L.arr.join(" ")}${L.arr.length>=20?" ‚Ä¶":""}]`).join("\n");
      const topDigits = pas.digitRank.slice(0, 10).map(([d,c]) => `${d}(${c})`).join("  ");
      const topPasPairs = Array.from(pas.candidates.entries()).sort((a,b)=>b[1]-a[1]).slice(0, 12)
        .map(([p,s]) => `${p}(${s})`).join("  ");
      pascalBox.textContent =
`SEED (DB): ${seedStr}
DIGIT rank: ${topDigits}
CANDIDATES: ${topPasPairs}

${layerStr}`;
    }

    const headRank = stats.headCnt.map((c,i)=>({d:i,c})).sort((a,b)=>b.c-a.c);
    const tailRank = stats.tailCnt.map((c,i)=>({d:i,c})).sort((a,b)=>b.c-a.c);
    headsEl.textContent = headRank.map(x=>`${x.d}:${x.c}`).join("  |  ");
    tailsEl.textContent = tailRank.map(x=>`${x.d}:${x.c}`).join("  |  ");

    const axisRank = sortMapDesc(stats.axisCnt).slice(0, 12);
    axisBox.innerHTML = `<div class="muted good">Top tr·ª•c (a-b):</div><div class="mono muted">${axisRank.map(([k,c])=>`${k}:${c}`).join("  |  ") || "--"}</div>`;

    tblHot.innerHTML = "";
    scored.slice(0, topN).forEach((x,i)=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${i+1}</td><td class="mono good">${x.pair}</td><td>${x.hot}</td><td>${x.gan}</td><td>${round2(x.score)}</td><td class="muted">${escapeHtml(x.why)}</td>`;
      tblHot.appendChild(tr);
    });

    tblGan.innerHTML = "";
    scored.slice().sort((a,b)=>b.gan-a.gan).slice(0, topN).forEach((x,i)=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${i+1}</td><td class="mono good">${x.pair}</td><td>${x.gan}</td><td>${x.hot}</td><td>${round2(x.score)}</td><td class="muted">${escapeHtml(x.why)}</td>`;
      tblGan.appendChild(tr);
    });

    if(!picks){
      pickBox.innerHTML = `<span class="tag bad">Ch∆∞a ch·ªët</span> Kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ ch·ªët.`;
    } else {
      pickBox.innerHTML = `
        <div class="row"><span class="tag ok">CH√çNH</span><span class="mono big">${picks.main.pair}</span><span class="pill">score ${round2(picks.main.score)}</span><span class="pill">${escapeHtml(picks.main.why)}</span></div>
        <div class="sep"></div>
        <div class="row"><span class="tag warn">PH·ª§</span><span class="mono big">${picks.side.pair}</span><span class="pill">score ${round2(picks.side.score)}</span><span class="pill">${escapeHtml(picks.side.why)}</span></div>
        <div class="sep"></div>
        <div class="row"><span class="tag bad">PH√íNG TH·ª¶</span><span class="mono big">${picks.hedge.pair}</span><span class="pill">score ${round2(picks.hedge.score)}</span><span class="pill">${escapeHtml(picks.hedge.why)}</span></div>
      `;
    }

    antiBox.innerHTML = warnings.map(w => `<div class="row"><span class="tag ${w.t}">${w.t.toUpperCase()}</span><span class="muted">${escapeHtml(w.m)}</span></div>`).join("")
      || `<span class="tag ok">OK</span> Kh√¥ng th·∫•y c·∫£nh b√°o l·ªõn.`;
  }

  // ===== OCR + CROP =====
  let loadedImg = null;
  let crop = { x: 20, y: 20, w: 200, h: 120 };
  let dragging = false;
  let dragOffset = { x: 0, y: 0 };
  let resizing = false;
  let activeHandle = null;

  function clearCanvas(){ ctxImg.clearRect(0,0,imgCanvas.width,imgCanvas.height); }

  btnCamera.addEventListener("click", () => fileCamera.click());
  btnUpload.addEventListener("click", () => fileUpload.click());

  fileCamera.addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if(!file) return;
    await processBatch([file]);
  });

  fileUpload.addEventListener("change", async (e) => {
    const files = Array.from(e.target.files || []);
    if (!files.length) return;
    await processBatch(files);
  });

  function drawPreview(){
    if(!loadedImg){ clearCanvas(); return; }
    ctxImg.clearRect(0,0,imgCanvas.width,imgCanvas.height);
    ctxImg.drawImage(loadedImg, 0, 0, imgCanvas.width, imgCanvas.height);

    ctxImg.save();
    ctxImg.fillStyle = "rgba(0,0,0,0.35)";
    ctxImg.beginPath();
    ctxImg.rect(0,0,imgCanvas.width,imgCanvas.height);
    ctxImg.rect(crop.x, crop.y, crop.w, crop.h);
    ctxImg.fill("evenodd");
    ctxImg.restore();

    ctxImg.save();
    ctxImg.strokeStyle = "rgba(255,255,255,0.95)";
    ctxImg.lineWidth = 2;
    ctxImg.strokeRect(crop.x, crop.y, crop.w, crop.h);

    const hs = 10;
    const handles = getHandles();
    ctxImg.fillStyle = "#fff";
    Object.values(handles).forEach(h=> ctxImg.fillRect(h.x - hs/2, h.y - hs/2, hs, hs));
    ctxImg.restore();
  }

  function getHandles(){
    return {
      tl:{x:crop.x,y:crop.y},
      tr:{x:crop.x+crop.w,y:crop.y},
      bl:{x:crop.x,y:crop.y+crop.h},
      br:{x:crop.x+crop.w,y:crop.y+crop.h},
    };
  }
  function hitHandle(px,py){
    const hs = 14;
    const handles = getHandles();
    for (const k of Object.keys(handles)){
      const h = handles[k];
      if (Math.abs(px-h.x)<=hs && Math.abs(py-h.y)<=hs) return k;
    }
    return null;
  }
  function inCrop(px,py){
    return px>=crop.x && px<=crop.x+crop.w && py>=crop.y && py<=crop.y+crop.h;
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  imgCanvas.addEventListener("pointerdown",(e)=>{
    if(!loadedImg) return;
    const r = imgCanvas.getBoundingClientRect();
    const px = (e.clientX - r.left) * (imgCanvas.width / r.width);
    const py = (e.clientY - r.top) * (imgCanvas.height / r.height);

    const h = hitHandle(px,py);
    if(h){ resizing = true; activeHandle = h; }
    else if(inCrop(px,py)){ dragging = true; dragOffset.x = px - crop.x; dragOffset.y = py - crop.y; }
    imgCanvas.setPointerCapture(e.pointerId);
  });

  imgCanvas.addEventListener("pointermove",(e)=>{
    if(!loadedImg) return;
    if(!dragging && !resizing) return;

    const r = imgCanvas.getBoundingClientRect();
    const px = (e.clientX - r.left) * (imgCanvas.width / r.width);
    const py = (e.clientY - r.top) * (imgCanvas.height / r.height);

    if(dragging){
      crop.x = clamp(px - dragOffset.x, 0, imgCanvas.width - crop.w);
      crop.y = clamp(py - dragOffset.y, 0, imgCanvas.height - crop.h);
    }

    if(resizing){
      const minW = 120, minH = 120;
      let x=crop.x, y=crop.y, w=crop.w, h=crop.h;

      if(activeHandle==="br"){
        w = clamp(px - x, minW, imgCanvas.width - x);
        h = clamp(py - y, minH, imgCanvas.height - y);
      } else if(activeHandle==="tr"){
        w = clamp(px - x, minW, imgCanvas.width - x);
        const ny = clamp(py, 0, y + h - minH);
        h = (y + h) - ny; y = ny;
      } else if(activeHandle==="bl"){
        const nx = clamp(px, 0, x + w - minW);
        w = (x + w) - nx; x = nx;
        h = clamp(py - y, minH, imgCanvas.height - y);
      } else if(activeHandle==="tl"){
        const nx = clamp(px, 0, x + w - minW);
        const ny = clamp(py, 0, y + h - minH);
        w = (x + w) - nx; x = nx;
        h = (y + h) - ny; y = ny;
      }
      crop = {x,y,w,h};
    }

    drawPreview();
  });

  imgCanvas.addEventListener("pointerup",()=>{
    dragging = false; resizing = false; activeHandle = null;
  });

  function loadFileAsync(file){
    return new Promise((resolve) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        loadedImg = img;

        const maxW = Math.min(980, window.innerWidth - 60);
        const scale = Math.min(1, maxW / img.width);
        imgCanvas.width = Math.floor(img.width * scale);
        imgCanvas.height = Math.floor(img.height * scale);

        // crop m·∫∑c ƒë·ªãnh t·ªëi ∆∞u ·∫£nh app b·∫°n (t·ª´ ti√™u ƒë·ªÅ xu·ªëng h√†ng 7)
        crop.w = Math.floor(imgCanvas.width * 0.92);
        crop.h = Math.floor(imgCanvas.height * 0.82);
        crop.x = Math.floor((imgCanvas.width - crop.w)/2);
        crop.y = Math.floor(imgCanvas.height * 0.10);

        drawPreview();
        resolve();
      };
      img.onerror = () => resolve();
      img.src = url;
    });
  }

  async function processBatch(files){
    inputEl.value = "";
    renderEmpty();
    setStatus(`Batch: ${files.length} ·∫£nh. ƒêang x·ª≠ l√Ω‚Ä¶`);

    for (let i=0;i<files.length;i++){
      setStatus(`Batch ${i+1}/${files.length}: load‚Ä¶`);
      await loadFileAsync(files[i]);

      await doOCR_AI();
      const line = buildLineFromAppMB(ocrText.value);

      if(line){
        inputEl.value += (inputEl.value ? "\n" : "") + line;
      }
    }

    setStatus(`Batch xong: ${files.length} ng√†y. ƒêang ch·∫°y FULL‚Ä¶`);
    runFull();
  }

  async function doOCR_AI(){
    try{
      setStatus("AI Scan: l√†m s·∫°ch ·∫£nh ‚Üí OCR‚Ä¶");
      ocrText.value = "";
      ocrPairs.textContent = "--";

      const scale = 3.0;
      const tmp = document.createElement("canvas");
      tmp.width = Math.floor(crop.w * scale);
      tmp.height = Math.floor(crop.h * scale);
      const tctx = tmp.getContext("2d");

      tctx.drawImage(imgCanvas, crop.x, crop.y, crop.w, crop.h, 0, 0, tmp.width, tmp.height);

      // preprocess threshold (h·ª£p ·∫£nh app KQXS)
      const imgData = tctx.getImageData(0, 0, tmp.width, tmp.height);
      const d = imgData.data;
      for(let i=0;i<d.length;i+=4){
        const g = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
        const c = (g - 128) * 1.45 + 128;
        const v = c > 160 ? 255 : 0;
        d[i]=d[i+1]=d[i+2]=v;
      }
      tctx.putImageData(imgData, 0, 0);

      const result = await Tesseract.recognize(tmp, "eng", {
        logger: (m) => {
          if (m.status) setStatus(`AI Scan: ${m.status} ${Math.round((m.progress||0)*100)}%`);
        }
      });

      const text = (result?.data?.text || "").trim();
      ocrText.value = text || "";
      const pairs = smartExtractPairs(text);
      ocrPairs.textContent = pairs.length ? pairs.join(" ") : "--";
      setStatus(pairs.length ? `AI Scan xong: b√≥c ${pairs.length} c·∫∑p.` : "AI Scan xong nh∆∞ng ch∆∞a th·∫•y s·ªë.");
    } catch(e){
      console.error(e);
      setStatus("AI Scan l·ªói. Th·ª≠ crop s√°t h∆°n.");
    }
  }

  function smartExtractPairs(text){
    const nums = (String(text).match(/\d{2,6}/g) || []);
    const pairs = nums.map(n => n.slice(-2));
    return Array.from(new Set(pairs)).filter(p => /^\d{2}$/.test(p));
  }

  // === Map ƒë√∫ng app Mi·ªÅn B·∫Øc nh∆∞ ·∫£nh b·∫°n g·ª≠i ===
  function buildLineFromAppMB(text){
    const t = String(text || "");
    const nums = (t.match(/\d{2,6}/g) || []);
    if(!nums.length) return "";

    // date: dd/mm/yyyy
    let date = "";
    const dm = t.match(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/);
    if(dm) date = `${dm[1]}/${dm[2]}`;

    // DB: s·ªë 5 ch·ªØ s·ªë l·ªõn nh·∫•t/ƒë·∫ßu b·∫£ng, l·∫•y 2 s·ªë cu·ªëi
    let DB = "";
    const dbLong = nums.find(n => n.length >= 5);
    DB = (dbLong ? dbLong.slice(-2) : nums[0].slice(-2));

    // V·ªõi app n√†y: G7 l√† 4 s·ªë 2 ch·ªØ s·ªë ƒë·ªè ·ªü cu·ªëi => 4 last2 cu·ªëi
    const allLast2 = nums.map(n => n.slice(-2));
    const G7 = allLast2.slice(-4);

    // G6 l√† 3 s·ªë 3 ch·ªØ s·ªë: 206 200 971 => last2: 06 00 71
    const G6 = allLast2.slice(-7, -4);

    return `${date ? date + ": " : ""}DB ${DB} | G7: ${G7.join(" ")} | G6: ${G6.join(" ")}`;
  }

  // init
  renderEmpty();
  setStatus("Ch∆∞a c√≥ ·∫£nh.");
})();
</script>
</body>
</html>
