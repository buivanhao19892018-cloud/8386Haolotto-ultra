<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>B√πi H√†o ‚Äî LOTTO MB GOD MODE (ULTRA MASTER+++)</title>
<meta name="theme-color" content="#0b1220"/>

<style>
:root{
  --card:#0b1730;--card2:#0a1427;--text:#e8f0ff;--muted:#a8b7d6;
  --line:rgba(255,255,255,.10);--good:#32d583;--warn:#fdb022;--bad:#ff4d4f;
  --btn:#1e5eff;--btn2:#1a3fa8;
}
*{box-sizing:border-box}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#06101f,#050b16);color:var(--text);padding:14px}
.wrap{max-width:1020px;margin:0 auto}
.card{background:linear-gradient(180deg,var(--card),var(--card2));border:1px solid var(--line);border-radius:16px;padding:14px;margin-bottom:12px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
h1,h2{margin:0 0 8px}
.hint{color:var(--muted);font-size:13px;line-height:1.35}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:10px}
.btn{appearance:none;border:0;cursor:pointer;background:linear-gradient(180deg,var(--btn),var(--btn2));color:#fff;font-weight:800;padding:10px 14px;border-radius:12px}
.btn.ghost{background:rgba(255,255,255,.06);border:1px solid var(--line);font-weight:700}
.btn.danger{background:linear-gradient(180deg,#ff4d4f,#b42318)}
.badge{padding:6px 10px;border-radius:999px;border:1px solid var(--line);font-size:12px}
.badge.ok{color:var(--good)} .badge.warn{color:var(--warn)} .badge.fail{color:var(--bad)}
textarea{width:100%;min-height:170px;border-radius:12px;border:1px solid var(--line);background:rgba(255,255,255,.06);color:var(--text);padding:10px;outline:none}
.grid{display:grid;grid-template-columns:1fr;gap:10px}
@media(min-width:860px){.grid{grid-template-columns:1.2fr .8fr}}
.mono{white-space:pre-wrap;word-break:break-word;background:rgba(0,0,0,.25);border:1px solid var(--line);border-radius:12px;padding:12px;font-size:13px;overflow:auto}
.field{border:1px solid var(--line);background:rgba(255,255,255,.06);border-radius:12px;padding:10px;min-width:160px}
.field label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
.field input,.field select{width:100%;border:0;background:transparent;color:var(--text);outline:none}
table{width:100%;border-collapse:collapse}
th,td{border-bottom:1px solid var(--line);padding:8px;text-align:left;font-size:12.5px;color:var(--text);vertical-align:top}
th{color:var(--muted);font-weight:800}
.small{color:var(--muted);font-size:12px}
hr{border:0;border-top:1px solid var(--line);margin:10px 0}
</style>
</head>

<body>
<div class="wrap">

<div class="card">
  <h1>B√πi H√†o ‚Äî LOTTO MB GOD MODE (ULTRA MASTER+++)</h1>
  <div class="hint">
    T·∫≠p trung <b>LOTO 2 s·ªë (MB)</b>. Output: <b>4 s·ªë + %</b> + <b>ƒê·ªçc pha</b> + <b>Anti-b·∫´y m·∫°nh</b> + <b>Backtest</b> + <b>Nh·∫≠t k√Ω</b>.
    <br/>Format m·ªói d√≤ng: <b>DB xx | G7: a b c d | G6: xxx yyy zzz</b>
  </div>

  <div class="row">
    <button class="btn" id="btnSample">D√°n m·∫´u</button>
    <button class="btn ghost" id="btnImport">Import log</button>
    <button class="btn ghost" id="btnExport">Export log</button>
    <button class="btn danger" id="btnClearAll">X√≥a d·ªØ li·ªáu + log</button>
  </div>
</div>

<div class="card">
  <h2>D·ªØ li·ªáu l·ªãch s·ª≠</h2>
  <div class="grid">
    <div>
      <textarea id="inputData" placeholder="D√°n d·ªØ li·ªáu t·∫°i ƒë√¢y..."></textarea>

      <div class="row">
        <div class="field">
          <label>Th·ª© t·ª± d·ªØ li·ªáu</label>
          <select id="orderMode">
            <option value="newest_first" selected>Newest ·ªü tr√™n (hay d√πng)</option>
            <option value="oldest_first">Oldest ·ªü tr√™n</option>
          </select>
        </div>

        <div class="field">
          <label>Window soi (ng√†y)</label>
          <input id="winDays" type="number" value="20" min="8" max="60"/>
        </div>

        <div class="field">
          <label>Top ch·ªët</label>
          <input id="topK" type="number" value="4" min="4" max="8"/>
        </div>

        <div class="field">
          <label>AI gi√°m s√°t</label>
          <select id="aiMode">
            <option value="on" selected>ON (c·∫£nh b√°o m·∫°nh)</option>
            <option value="soft">SOFT</option>
            <option value="off">OFF</option>
          </select>
        </div>

        <div class="field">
          <label>Ng∆∞·ª°ng TR·ª§C n·ªïi</label>
          <input id="thrTruc" type="number" value="4" min="2" max="12"/>
        </div>
      </div>

      <div class="row">
        <button class="btn" id="btnRun">üöÄ CH·∫†Y GOD MODE</button>
        <span class="badge ok" id="st">Ready</span>
      </div>

      <div class="small" style="margin-top:6px">
        * G·ª£i √Ω: mu·ªën backtest r√µ ‚Üí d√°n ‚â• 15‚Äì25 d√≤ng.
      </div>
    </div>

    <div>
      <h2 style="margin-top:0">K·∫æT QU·∫¢ CH·ªêT ‚Äî 4 S·ªê + %</h2>
      <div class="mono" id="out">Ch∆∞a ch·∫°y.</div>
      <hr/>
      <h2 style="margin-top:0">ƒê·ªåC PHA ‚Äî AI GI√ÅM S√ÅT</h2>
      <div class="mono" id="phaseOut">Ch∆∞a ch·∫°y.</div>
    </div>
  </div>
</div>

<div class="card">
  <h2>BACKTEST (T·ª∞ TEST TR√äN D·ªÆ LI·ªÜU)</h2>
  <div class="hint">
    C∆° ch·∫ø: d√πng <b>window</b> ng√†y tr∆∞·ªõc ƒë√≥ ƒë·ªÉ ‚Äúd·ª± ƒëo√°n‚Äù ng√†y k·∫ø ti·∫øp ‚Üí check tr√∫ng theo <b>DB2 th·ª±c t·∫ø</b>.
    <br/>M·ª•c ti√™u: nh√¨n ra <b>pha n√†o ƒëang ƒÉn th·∫≠t</b> v√† app c√≥ ‚Äú·∫£o‚Äù hay kh√¥ng.
  </div>
  <div class="mono" id="btOut">Ch∆∞a ch·∫°y.</div>
</div>

<div class="card">
  <h2>NH·∫¨T K√ù GOD MODE (log)</h2>
  <div class="hint">L∆∞u l·∫ßn ch·∫°y g·∫ßn nh·∫•t + pha + top4 + c·∫£nh b√°o. D√πng ƒë·ªÉ ‚Äúng√†y n√†o ƒÉn ki·ªÉu g√¨‚Äù.</div>
  <div class="row">
    <button class="btn ghost" id="btnClearLog">X√≥a log</button>
  </div>
  <div style="margin-top:10px;overflow:auto">
    <table id="logTable">
      <thead>
        <tr>
          <th>Th·ªùi gian</th>
          <th>Pha</th>
          <th>H∆∞·ªõng</th>
          <th>Top (4)</th>
          <th>C·∫£nh b√°o</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <div class="small" style="margin-top:8px">¬© B√πi H√†o ‚Äî GOD MODE h·ªó tr·ª£ ph√¢n t√≠ch. Kh√¥ng ƒë·∫£m b·∫£o tr√∫ng.</div>
</div>

<input id="fileImport" type="file" accept="application/json" hidden/>

<script>
/* =========================
   UTIL
========================= */
const el = (id)=>document.getElementById(id);
const pad2 = (n)=>String(n).padStart(2,"0");
const nowStamp = ()=>new Date().toLocaleString();

function setStatus(text, cls){
  const s = el("st");
  s.textContent = text;
  s.classList.remove("ok","warn","fail");
  s.classList.add(cls);
}

function safeNum(n, d=0){ n=Number(n); return Number.isFinite(n)?n:d; }

/* =========================
   PARSE
========================= */
function parseLines(){
  const raw = el("inputData").value.trim().split("\n").map(x=>x.trim()).filter(Boolean);
  const days = [];

  for(const line of raw){
    const dbm = line.match(/DB\s+(\d{2})/);
    const g7m = line.match(/G7:\s*([0-9 ]+)/);
    const g6m = line.match(/G6:\s*([0-9 ]+)/);
    if(!dbm || !g7m || !g6m) continue;

    const db2 = pad2(dbm[1]);
    const g7 = (g7m[1].match(/\b\d{2}\b/g)||[]).slice(0,4).map(pad2);
    const g6 = (g6m[1].match(/\b\d{3}\b/g)||[]).slice(0,3);
    const g6_2 = g6.map(x=>pad2(x.slice(-2)));

    // signal = DB2 + G7 (ƒë√∫ng LOTO)
    const signal = [db2, ...g7];
    // ref = G6_2 (ph·ª•)
    const ref = [...g6_2];
    const pool = [...signal, ...ref];

    days.push({ db2, g7, g6_2, signal, ref, pool, raw: line });
  }

  // normalize order to chronological (oldest -> newest)
  // user setting: newest_first means raw[0] is newest => reverse
  const order = el("orderMode").value;
  if(order === "newest_first") days.reverse();

  return days; // oldest->newest
}

/* =========================
   MASTER+++ SCORE (TopK + %)
   - tr·ªçng t√¢m: signal 80% + ref 20%
   - gan m·ªÅm + anti-gan=0
========================= */
function buildPrediction(windowDays){
  // windowDays: array of past days (oldest->newest), used to predict next day
  const freq = {};
  const lastSeen = {};
  const wSig = 0.8, wRef = 0.2;

  // count weighted freq
  windowDays.forEach((d, idx)=>{
    d.signal.forEach(n=>{
      freq[n] = (freq[n]||0) + wSig;
      if(lastSeen[n] === undefined) lastSeen[n] = idx; // first time from oldest
    });
    d.ref.forEach(n=>{
      freq[n] = (freq[n]||0) + wRef;
      if(lastSeen[n] === undefined) lastSeen[n] = idx;
    });
  });

  // gan (days since last appearance) from end
  const lastFromEnd = {};
  for(let i=windowDays.length-1;i>=0;i--){
    const d = windowDays[i];
    d.signal.concat(d.ref).forEach(n=>{
      if(lastFromEnd[n] === undefined) lastFromEnd[n] = (windowDays.length-1 - i);
    });
  }

  const score = {};
  for(let i=0;i<100;i++){
    const n = pad2(i);
    const hot = safeNum(freq[n],0);

    const gan = (lastFromEnd[n] === undefined) ? 999 : lastFromEnd[n];
    let ganScore = 0;
    if(gan===999) ganScore = -2.8;
    else if(gan===0) ganScore = -1.2;          // v·ª´a ra ‚Üí ph·∫°t
    else if(gan>=1 && gan<=3) ganScore = 2.2;  // gan ƒë·∫πp
    else if(gan>=4 && gan<=8) ganScore = 0.9;
    else ganScore = -0.3;

    // t·ªïng h·ª£p
    score[n] = hot*2.0 + ganScore*1.4;
  }

  const sorted = Object.entries(score).sort((a,b)=>b[1]-a[1]);

  // map score -> pseudo %
  const top = sorted.slice(0, 12);
  const maxS = top[0]?.[1] ?? 1;
  const minS = top[top.length-1]?.[1] ?? 0;
  const toPct = (s)=>{
    // normalize to 52..92 range
    const t = (maxS===minS) ? 0.5 : ( (s-minS)/(maxS-minS) );
    return (52 + t*40);
  };

  return { sorted, toPct };
}

/* =========================
   PHA MASTER+++ (pha‚Äìtr·ª•c‚Äìx·∫£‚Äìm·ªü)
   - P1 G7 Lead
   - P2 Tr·ª•c Lead
   - P3 Giao thoa
   - P4 Nhi·ªÖu/B·∫´y
   - P5 X·∫£ (ƒë·∫£o m·∫°nh sau chu·ªói d·ªìn)
   - P6 M·ªü (t√≠n hi·ªáu ƒë·ªìng thu·∫≠n + √≠t c·∫£nh b√°o)
========================= */
function head(n){ return parseInt(n[0],10); }
function tail(n){ return parseInt(n[1],10); }
function canonTruc(n){
  const a = head(n), b = tail(n);
  const k1 = `${a}-${b}`, k2 = `${b}-${a}`;
  return (k1 < k2) ? k1 : k2;
}
function entropy10(counts){
  const sum = counts.reduce((a,b)=>a+b,0) || 1;
  let e = 0;
  for(const c of counts){
    if(!c) continue;
    const p = c/sum;
    e += -p*Math.log2(p);
  }
  return e;
}

function readPhaseFromWindow(windowDays){
  const thrTruc = safeNum(el("thrTruc").value, 4);
  const recent = windowDays.slice(-5); // newest 5 days in window

  const headCnt = Array(10).fill(0);
  const tailCnt = Array(10).fill(0);
  const chamCnt = Array(10).fill(0);
  const trucCnt = {};

  recent.forEach(d=>{
    d.signal.forEach(n=>{
      headCnt[head(n)]++;
      tailCnt[tail(n)]++;
      chamCnt[head(n)]++; chamCnt[tail(n)]++;
      const k = canonTruc(n);
      trucCnt[k] = (trucCnt[k]||0)+1;
    });
  });

  const topHead = headCnt.map((v,i)=>[i,v]).sort((a,b)=>b[1]-a[1]).slice(0,3);
  const topTail = tailCnt.map((v,i)=>[i,v]).sort((a,b)=>b[1]-a[1]).slice(0,3);
  const topCham = chamCnt.map((v,i)=>[i,v]).sort((a,b)=>b[1]-a[1]).slice(0,3);
  const topTruc = Object.entries(trucCnt).sort((a,b)=>b[1]-a[1]).slice(0,5).map(([k,v])=>({truc:k, score:v}));

  const headStr = topHead[0]?.[1]||0;
  const tailStr = topTail[0]?.[1]||0;
  const chamStr = topCham[0]?.[1]||0;
  const trucStr = topTruc[0]?.score||0;

  // nhi·ªÖu (entropy cao = r·∫£i)
  const eHead = entropy10(headCnt);
  const eTail = entropy10(tailCnt);

  // ch·∫•m ƒëi·ªÉm pha
  let p1=0,p2=0,p3=0,p4=0,p5=0,p6=0;
  // P1 (G7 lead)
  if(chamStr>=6) p1+=2;
  if(headStr>=4) p1+=1;
  if(tailStr>=4) p1+=1;
  if(trucStr < thrTruc) p1+=2;

  // P2 (Tr·ª•c lead)
  if(trucStr>=thrTruc) p2+=3;
  if(trucStr>=thrTruc+2) p2+=2;
  if(chamStr<=5) p2+=1;

  // P3 (Giao thoa)
  if(trucStr>=thrTruc && chamStr>=6) p3+=5;

  // P4 (Nhi·ªÖu)
  if(trucStr < thrTruc && chamStr<=5) p4+=3;
  if(eHead>2.8 && eTail>2.8) p4+=2;

  // P5 (X·∫£): tr∆∞·ªõc ƒë√≥ d·ªìn m·∫°nh nh∆∞ng hi·ªán t·∫°i r·∫£i m·∫°nh
  // heuristic: trong 10 ng√†y cu·ªëi c·ªßa window, c√≥ d·ªìn c·ª±c, c√≤n 5 ng√†y g·∫ßn nh·∫•t entropy cao
  const last10 = windowDays.slice(-10);
  const headCnt10 = Array(10).fill(0);
  const tailCnt10 = Array(10).fill(0);
  last10.forEach(d=>{
    d.signal.forEach(n=>{ headCnt10[head(n)]++; tailCnt10[tail(n)]++; });
  });
  const headMax10 = Math.max(...headCnt10), tailMax10 = Math.max(...tailCnt10);
  if((headMax10>=10 || tailMax10>=10) && (eHead>2.9 || eTail>2.9)) p5 += 5;

  // P6 (M·ªü): ƒë·ªìng thu·∫≠n + √≠t nhi·ªÖu
  if(p3>=5) p6 += 3;
  if(p2>=4 && eHead<2.7 && eTail<2.7) p6 += 3;
  if(p1>=4 && eHead<2.7) p6 += 2;

  const scores = [
    {pha:"P6 ‚Äî M·ªû", s:p6},
    {pha:"P3 ‚Äî GIAO THOA", s:p3},
    {pha:"P2 ‚Äî TR·ª§C LEAD", s:p2},
    {pha:"P1 ‚Äî G7 LEAD", s:p1},
    {pha:"P5 ‚Äî X·∫¢", s:p5},
    {pha:"P4 ‚Äî NHI·ªÑU/B·∫™Y", s:p4},
  ].sort((a,b)=>b.s-a.s);

  const best = scores[0];

  // h∆∞·ªõng soi
  let guide = "";
  if(best.pha.startsWith("P2")) guide = "∆ØU TI√äN TR·ª§C (G7 x√°c nh·∫≠n)";
  else if(best.pha.startsWith("P1")) guide = "∆ØU TI√äN G7/G6 (TR·ª§C ph·ª•)";
  else if(best.pha.startsWith("P3")) guide = "GIAO THOA: TR·ª§C l√†m khung, ch·ªçn ƒëinh t·ª´ G7";
  else if(best.pha.startsWith("P6")) guide = "M·ªû: c√≥ th·ªÉ ƒë√°nh m·∫°nh h∆°n (n·∫øu anti-b·∫´y OK)";
  else if(best.pha.startsWith("P5")) guide = "X·∫¢: gi·∫£m tay / n√© d√†n to (d·ªÖ ƒë·∫£o)";
  else guide = "NHI·ªÑU: KH√îNG N√äN ƒê√ÅNH / ch·ªâ quan s√°t";

  // anti-b·∫´y
  const warns = [];
  if(windowDays.length < 12) warns.push("Sample < 12: d·ªÖ l·ªách (app gi·∫£m tin c·∫≠y).");
  if(headStr>=8) warns.push("D·ªìn ƒê·∫¶U qu√° m·∫°nh ‚Üí b·∫´y d·ªìn.");
  if(tailStr>=8) warns.push("D·ªìn ƒêU√îI qu√° m·∫°nh ‚Üí b·∫´y d·ªìn.");
  if(best.pha.includes("NHI·ªÑU")) warns.push("Pha nhi·ªÖu ‚Üí n√©.");
  if(best.pha.includes("X·∫¢")) warns.push("Pha x·∫£ ‚Üí d·ªÖ ƒë·∫£o nh·ªãp.");
  if(eHead>2.95 && eTail>2.95) warns.push("R·∫£i qu√° r·ªông ‚Üí nhi·ªÖu cao.");

  return {
    best, scores, guide, warns,
    signals: { topHead, topTail, topCham, topTruc, eHead, eTail, headStr, tailStr, chamStr, trucStr }
  };
}

/* =========================
   MAIN RUN (latest prediction + log)
========================= */
function runGodMode(){
  const days = parseLines(); // oldest->newest
  const win = Math.max(8, safeNum(el("winDays").value, 20));
  const topK = Math.max(4, safeNum(el("topK").value, 4));
  const aiMode = el("aiMode").value;

  if(days.length < win+1){
    setStatus("Thi·∫øu d·ªØ li·ªáu", "fail");
    el("out").textContent = `‚ùå C·∫ßn √≠t nh·∫•t ${win+1} d√≤ng (window ${win} + 1 ng√†y ƒë·ªÉ ·ªïn).`;
    el("phaseOut").textContent = "‚Äî";
    el("btOut").textContent = "‚Äî";
    return;
  }

  // Latest run: use last 'win' days (newest window) to predict "ng√†y ti·∫øp theo"
  const windowDays = days.slice(-win);
  const pred = buildPrediction(windowDays);
  const phase = readPhaseFromWindow(windowDays);

  const top = pred.sorted.slice(0, topK).map(([n,s])=>({n, s, pct: pred.toPct(s)}));
  const main = top[0]?.n || "--";

  // Decision gate (c·∫£nh b√°o m·∫°nh)
  let hardStop = false;
  if(aiMode !== "off"){
    const w = phase.warns.length;
    if(phase.best.pha.includes("NHI·ªÑU") || phase.best.pha.includes("X·∫¢")) hardStop = true;
    if(w >= 2) hardStop = true;
  }

  // Output ch·ªët
  let out = `TOP ${topK} S·ªê ∆ØU TI√äN (LOTO 2 S·ªê):\n`;
  top.forEach((x,i)=>{
    out += `${i+1}. ${x.n}  ‚Üí  ${x.pct.toFixed(1)}%\n`;
  });

  out += `\nCH·ªêT GOD MODE:\n`;
  out += `üéØ M≈©i ch√≠nh: ${main}\n`;
  out += `üß© B·ªô 4: ${top.map(x=>x.n).join(" ")}\n`;
  out += `\nGHI CH√ö:\n- % l√† ch·ªâ s·ªë tin c·∫≠y t∆∞∆°ng ƒë·ªëi trong window (kh√¥ng ph·∫£i x√°c su·∫•t th·∫≠t)\n`;

  if(aiMode === "on" && hardStop){
    out += `\n‚ùå AI GI√ÅM S√ÅT: KH√îNG N√äN ƒê√ÅNH (c·∫£nh b√°o m·∫°nh)\n`;
  }else if(aiMode === "soft" && hardStop){
    out += `\n‚ö†Ô∏è AI GI√ÅM S√ÅT: GI·∫¢M TAY / C·∫®N TR·ªåNG\n`;
  }else{
    out += `\n‚úÖ AI GI√ÅM S√ÅT: OK\n`;
  }

  el("out").textContent = out;

  // Phase output (MASTER+++)
  const sig = phase.signals;
  let ph = `[K·∫æT LU·∫¨N PHA ‚Äî MASTER+++]\n${phase.best.pha}  (score=${phase.best.s})\n\n`;
  ph += `[H∆Ø·ªöNG SOI]\n${phase.guide}\n\n`;
  ph += `[D·∫§U HI·ªÜU]\n`;
  ph += `- Tr·ª•c top: ${sig.topTruc.map(x=>`${x.truc}=${x.score}`).join(", ")||"(none)"}\n`;
  ph += `- ƒê·∫ßu m·∫°nh: ${sig.topHead.map(x=>`${x[0]}(${x[1]})`).join(", ")}\n`;
  ph += `- ƒêu√¥i m·∫°nh: ${sig.topTail.map(x=>`${x[0]}(${x[1]})`).join(", ")}\n`;
  ph += `- Ch·∫°m m·∫°nh: ${sig.topCham.map(x=>`${x[0]}(${x[1]})`).join(", ")}\n`;
  ph += `- Nhi·ªÖu (entropy): head=${sig.eHead.toFixed(2)} | tail=${sig.eTail.toFixed(2)}\n\n`;
  ph += `[ANTI-B·∫™Y]\n`;
  ph += phase.warns.length ? phase.warns.map(w=>`‚ö†Ô∏è ${w}`).join("\n") : "OK (ch∆∞a th·∫•y b·∫´y r√µ).";
  el("phaseOut").textContent = ph;

  // Backtest
  const bt = backtest(days, win, topK);
  el("btOut").textContent = bt.text;

  // Log (only log latest ‚Äúlive‚Äù run)
  const warnText = phase.warns.length ? phase.warns.join(" | ") : "OK";
  const logEntry = {
    ts: nowStamp(),
    pha: phase.best.pha,
    guide: phase.guide,
    top: top.map(x=>x.n),
    hardStop: (aiMode!=="off" && hardStop),
    warn: warnText
  };
  addLog(logEntry);
  setStatus("Done", "ok");
}

/* =========================
   BACKTEST (rolling)
   - For t from win to N-1:
     window = days[t-win .. t-1]
     predict topK
     hit if actual db2 at day t in topK
   - Also stats by phase
========================= */
function backtest(days, win, topK){
  const N = days.length;
  let total=0, hit=0;
  const byPha = {}; // pha -> {t,h}

  for(let t=win; t<N; t++){
    const windowDays = days.slice(t-win, t);
    const actual = days[t].db2;

    const pred = buildPrediction(windowDays);
    const top = pred.sorted.slice(0, topK).map(x=>x[0]);

    const phase = readPhaseFromWindow(windowDays);
    const pha = phase.best.pha;

    const ok = top.includes(actual);
    total++;
    if(ok) hit++;

    if(!byPha[pha]) byPha[pha] = {t:0,h:0};
    byPha[pha].t++;
    if(ok) byPha[pha].h++;
  }

  const rate = total? (hit/total*100):0;

  // build report
  let text = `BACKTEST (${total} l∆∞·ª£t) ‚Äî Top${topK} tr√∫ng DB2: ${hit}/${total} = ${rate.toFixed(1)}%\n`;
  text += `Window: ${win} ng√†y | Rule: d·ª±a tr√™n (DB2+G7) l√† ch√≠nh, G6_2 ph·ª•\n\n`;

  // phase table
  const rows = Object.entries(byPha).map(([pha, o])=>{
    const r = o.t ? (o.h/o.t*100) : 0;
    return {pha, t:o.t, h:o.h, r};
  }).sort((a,b)=>b.r-a.r);

  text += `[HI·ªÜU SU·∫§T THEO PHA]\n`;
  if(!rows.length){
    text += "(ch∆∞a ƒë·ªß d·ªØ li·ªáu)\n";
  }else{
    rows.forEach(x=>{
      text += `- ${x.pha}: ${x.h}/${x.t} = ${x.r.toFixed(1)}%\n`;
    });
  }

  // sanity warnings
  text += `\n[G·ª¢I √ù GOD MODE]\n`;
  if(days.length < 15) text += `‚ö†Ô∏è D·ªØ li·ªáu < 15: backtest ch∆∞a ƒë√°ng tin.\n`;
  if(rate < 20) text += `‚ö†Ô∏è T·ª∑ l·ªá th·∫•p: xem l·∫°i th·ª© t·ª± d·ªØ li·ªáu (newest/oldest) ho·∫∑c d·ªØ li·ªáu nh·∫≠p sai format.\n`;
  if(rate >= 35) text += `‚úÖ Kh√° ·ªïn: c√≥ th·ªÉ d√πng, nh∆∞ng v·∫´n ∆∞u ti√™n AI anti-b·∫´y.\n`;

  return {total, hit, rate, byPha, text};
}

/* =========================
   LOG (localStorage)
========================= */
const LOG_KEY = "bh_godmode_log_v1";

function loadLog(){
  try{
    const s = localStorage.getItem(LOG_KEY);
    const arr = s ? JSON.parse(s) : [];
    return Array.isArray(arr)?arr:[];
  }catch(e){ return []; }
}
function saveLog(arr){
  localStorage.setItem(LOG_KEY, JSON.stringify(arr.slice(0,200))); // keep 200
}
function addLog(entry){
  const arr = loadLog();
  arr.unshift(entry);
  saveLog(arr);
  renderLog();
}
function clearLog(){
  localStorage.removeItem(LOG_KEY);
  renderLog();
}
function renderLog(){
  const tb = el("logTable").querySelector("tbody");
  tb.innerHTML = "";
  const arr = loadLog();

  if(!arr.length){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td colspan="5" class="small">Ch∆∞a c√≥ log.</td>`;
    tb.appendChild(tr);
    return;
  }

  for(const it of arr){
    const tr = document.createElement("tr");
    const top = (it.top||[]).join(" ");
    const warn = it.hardStop ? ("‚ùå " + (it.warn||"C·∫£nh b√°o")) : (it.warn||"OK");
    tr.innerHTML = `
      <td>${it.ts||""}</td>
      <td>${it.pha||""}</td>
      <td>${it.guide||""}</td>
      <td><b>${top}</b></td>
      <td>${warn}</td>
    `;
    tb.appendChild(tr);
  }
}

/* =========================
   IMPORT / EXPORT LOG
========================= */
function exportLog(){
  const arr = loadLog();
  const blob = new Blob([JSON.stringify({exported_at: nowStamp(), log: arr}, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "BuiHao_GODMODE_log.json";
  a.click();
  URL.revokeObjectURL(url);
}
function importLogFile(file){
  const r = new FileReader();
  r.onload = ()=>{
    try{
      const obj = JSON.parse(String(r.result||"{}"));
      const incoming = Array.isArray(obj.log) ? obj.log : [];
      const cur = loadLog();
      const merged = [...incoming, ...cur].slice(0,200);
      saveLog(merged);
      renderLog();
      alert("Import log OK.");
    }catch(e){
      alert("File log kh√¥ng h·ª£p l·ªá.");
    }
  };
  r.readAsText(file);
}

/* =========================
   UI EVENTS
========================= */
el("btnRun").onclick = ()=>{
  setStatus("Running‚Ä¶", "warn");
  try{ runGodMode(); }catch(e){
    setStatus("Error", "fail");
    el("out").textContent = "‚ùå L·ªói runtime: " + (e?.message || e);
  }
};

el("btnSample").onclick = ()=>{
  // Newest on top sample (common). If user keeps newest_first, app will reverse internally.
  el("inputData").value =
`DB 59 | G7: 21 41 02 14 | G6: 003 063 087
DB 13 | G7: 77 19 86 10 | G6: 484 417 202
DB 14 | G7: 81 87 60 32 | G6: 206 200 971
DB 21 | G7: 76 47 21 77 | G6: 801 295 993
DB 45 | G7: 03 82 85 81 | G6: 392 255 854
DB 72 | G7: 30 92 51 66 | G6: 610 298 114
DB 08 | G7: 71 14 20 93 | G6: 514 608 371
DB 63 | G7: 19 82 63 27 | G6: 295 602 417
DB 07 | G7: 07 17 27 37 | G6: 107 217 327
DB 90 | G7: 90 09 19 29 | G6: 190 290 390
DB 33 | G7: 03 13 23 33 | G6: 133 233 333
DB 66 | G7: 16 26 36 46 | G6: 166 266 366
DB 41 | G7: 41 14 24 34 | G6: 141 241 341
DB 82 | G7: 82 28 18 08 | G6: 182 282 382
DB 05 | G7: 05 15 25 35 | G6: 105 205 305`;
};

el("btnClearAll").onclick = ()=>{
  if(confirm("X√≥a to√†n b·ªô d·ªØ li·ªáu + log?")){
    el("inputData").value = "";
    clearLog();
    el("out").textContent = "Ch∆∞a ch·∫°y.";
    el("phaseOut").textContent = "Ch∆∞a ch·∫°y.";
    el("btOut").textContent = "Ch∆∞a ch·∫°y.";
    setStatus("Cleared", "ok");
  }
};

el("btnClearLog").onclick = ()=>{
  if(confirm("X√≥a log?")) clearLog();
};

el("btnExport").onclick = exportLog;

el("btnImport").onclick = ()=> el("fileImport").click();
el("fileImport").addEventListener("change", (e)=>{
  const f = (e.target.files||[])[0];
  if(f) importLogFile(f);
  e.target.value = "";
});

// init
renderLog();
</script>

</div>
</body>
</html>
