<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>B√πi H√†o ‚Äî Lotto ULTRA MASTER (Upload-Fix ‚Ä¢ OCR Gate FINAL)</title>
  <meta name="theme-color" content="#0b1220" />
  <style>
    :root{
      --bg:#0b1220; --card:#0f1b2f; --muted:#9fb2d0; --text:#eaf1ff;
      --good:#27d07d; --bad:#ff4d4f; --warn:#ffb020; --line:#1c2d4d;
      --btn:#1f6fff; --btn2:#1d2a44;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    body{margin:0; font-family:var(--sans); background:linear-gradient(180deg,#070c16 0%, #0b1220 45%, #071021 100%); color:var(--text)}
    .wrap{max-width:980px; margin:0 auto; padding:16px 14px 40px}
    .title{font-weight:900; font-size:24px; letter-spacing:.2px}
    .sub{color:var(--muted); margin-top:6px; line-height:1.4}
    .grid{display:grid; gap:12px}
    @media(min-width:860px){ .grid{grid-template-columns: 1.15fr .85fr} }
    .card{background:rgba(15,27,47,.92); border:1px solid rgba(28,45,77,.85); border-radius:18px; padding:14px; box-shadow:0 12px 35px rgba(0,0,0,.35)}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .chip{padding:8px 10px; border-radius:999px; background:#0a1428; border:1px solid rgba(28,45,77,.85); color:var(--muted); font-size:13px}
    .chip.good{color:#d8ffe9; border-color:rgba(39,208,125,.35); background:rgba(39,208,125,.08)}
    .chip.bad{color:#ffe2e2; border-color:rgba(255,77,79,.35); background:rgba(255,77,79,.08)}
    .chip.warn{color:#fff2d8; border-color:rgba(255,176,32,.35); background:rgba(255,176,32,.08)}
    .btn{border:0; cursor:pointer; padding:12px 14px; border-radius:14px; font-weight:800; color:white; background:var(--btn); box-shadow:0 10px 22px rgba(31,111,255,.25)}
    .btn.secondary{background:var(--btn2); color:var(--text); border:1px solid rgba(28,45,77,.9); box-shadow:none}
    .btn.danger{background:#b71c1c; box-shadow:0 10px 22px rgba(183,28,28,.18)}
    .btn:disabled{opacity:.5; cursor:not-allowed}
    .lbl{font-size:13px; color:var(--muted); margin:8px 0 6px}
    textarea, input[type="number"], input[type="text"]{
      width:100%; padding:12px; border-radius:14px; background:#071326; border:1px solid rgba(28,45,77,.95);
      color:var(--text); outline:none;
    }
    textarea{min-height:170px; font-family:var(--mono); font-size:13px; line-height:1.35; resize:vertical}
    .mono{font-family:var(--mono)}
    .kpi{display:grid; grid-template-columns: repeat(2, 1fr); gap:10px}
    @media(min-width:500px){ .kpi{grid-template-columns: repeat(4, 1fr)} }
    .k{background:#071326; border:1px solid rgba(28,45,77,.95); border-radius:16px; padding:10px}
    .k .h{color:var(--muted); font-size:12px}
    .k .v{font-size:20px; font-weight:900; margin-top:4px}
    .sep{height:1px; background:rgba(28,45,77,.75); margin:12px 0}
    .small{font-size:12px; color:var(--muted)}
    img.preview{width:100%; border-radius:14px; border:1px solid rgba(28,45,77,.95); background:#050a12; display:block}
    .hide{display:none!important}
    .twoCol{display:grid; gap:10px}
    @media(min-width:520px){ .twoCol{grid-template-columns:1fr 1fr} }
    .note{padding:10px 12px; border-radius:14px; background:#071326; border:1px dashed rgba(255,176,32,.45); color:#ffeac2; font-size:13px; line-height:1.4}
    .okline{color:#d8ffe9}
    .badline{color:#ffe2e2}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="title">B√πi H√†o ‚Äî Lotto ULTRA MASTER <span class="mono">(Upload-Fix ‚Ä¢ OCR Gate FINAL)</span></div>
      <div class="sub">
        Lu·ªìng chu·∫©n: <b>Upload nhi·ªÅu ·∫£nh</b> ‚Üí <b>OCR (Tesseract.js)</b> ‚Üí <b>Parse ƒêB/G6/G7 (gate c·ª©ng)</b> ‚Üí ch·ªâ <b>PASS</b> m·ªõi ƒë·ªï d·ªØ li·ªáu ‚Üí ch·∫°y FULL.
        <div class="small">M·∫πo: crop s√°t ph·∫ßn b·∫£ng (t·ª´ ‚ÄúƒêB‚Äù ƒë·∫øn h√†ng ‚Äú7‚Äù), tr√°nh d√≠nh header ng√†y/th√°ng v√† footer tab Mi·ªÅn B·∫Øc/Trung/Nam.</div>
      </div>
      <div class="sep"></div>
      <div class="row">
        <span id="chipHttps" class="chip">HTTPS: ki·ªÉm tra‚Ä¶</span>
        <span id="chipTess" class="chip">Tesseract: ch∆∞a t·∫£i</span>
        <span id="chipBatch" class="chip">Batch: 0 ·∫£nh</span>
        <span id="chipGate" class="chip">Gate: ‚Äî</span>
      </div>

      <div class="sep"></div>

      <!-- Upload FIX: d√πng label + input th·∫≠t (ƒë·ª° l·ªói click kh√¥ng m·ªü ch·ªçn ·∫£nh tr√™n mobile) -->
      <div class="row">
        <label class="btn" for="fileInput">üì∑ Upload nhi·ªÅu ·∫£nh</label>
        <input id="fileInput" type="file" accept="image/*" multiple capture="environment" class="hide" />

        <button class="btn secondary" id="btnPaste">üìã D√°n ·∫£nh (n·∫øu c√≥)</button>
        <button class="btn danger" id="btnClear">üßπ X√≥a</button>
        <button class="btn secondary" id="btnRunFull">üöÄ Ch·∫°y FULL</button>
      </div>

      <div class="sep"></div>

      <div class="grid">
        <div class="card">
          <div class="lbl">·∫¢nh g·∫ßn nh·∫•t</div>
          <img id="imgPreview" class="preview hide" alt="preview" />
          <div id="noPreview" class="note">Ch∆∞a c√≥ ·∫£nh. N·∫øu b·∫•m Upload kh√¥ng m·ªü: h√£y d√πng <b>Chrome</b> v√† ƒë·∫£m b·∫£o URL l√† <b>https</b> (GitHub Pages).</div>

          <div class="sep"></div>

          <div class="lbl">K·∫øt qu·∫£ parse (·∫£nh cu·ªëi)</div>
          <div class="kpi">
            <div class="k">
              <div class="h">ƒêB (2 s·ªë)</div>
              <div class="v" id="outDB">‚Äî</div>
            </div>
            <div class="k">
              <div class="h">G6 (3 s·ªë)</div>
              <div class="v mono" id="outG6">‚Äî</div>
            </div>
            <div class="k">
              <div class="h">G7 (4 s·ªë)</div>
              <div class="v mono" id="outG7">‚Äî</div>
            </div>
            <div class="k">
              <div class="h">Tr·∫°ng th√°i</div>
              <div class="v" id="outStatus">‚Äî</div>
            </div>
          </div>

          <div class="sep"></div>

          <div class="lbl">S·ª≠a tay (ch·ªâ khi Gate FAIL) ‚Äî b·∫•m ‚Äú√Åp manual ‚Üí th√™m d√≤ng‚Äù</div>
          <div class="twoCol">
            <input id="manDB" type="text" placeholder="DB (2 s·ªë) VD: 45" />
            <input id="manG7" type="text" placeholder="G7 (4 s·ªë) VD: 03 82 85 81" />
          </div>
          <div style="height:10px"></div>
          <input id="manG6" type="text" placeholder="G6 (3 s·ªë) VD: 392 255 854" />
          <div style="height:10px"></div>
          <button class="btn" id="btnManualAdd">‚úÖ √Åp manual ‚Üí th√™m d√≤ng</button>

          <div class="sep"></div>

          <div class="lbl">Debug OCR (r√∫t g·ªçn)</div>
          <textarea id="dbg" readonly></textarea>
        </div>

        <div class="card">
          <div class="lbl">D·ªØ li·ªáu ƒë·∫ßu v√†o (m·ªói d√≤ng = 1 ng√†y)</div>
          <div class="small">Format chu·∫©n: <span class="mono">DB xx | G7: a b c d | G6: xxx yyy zzz</span></div>
          <textarea id="data"></textarea>

          <div class="row">
            <button class="btn secondary" id="btnCopyAll">üìÑ Copy to√†n b·ªô</button>
            <button class="btn secondary" id="btnClearData">üßΩ X√≥a d·ªØ li·ªáu</button>
          </div>

          <div class="sep"></div>

          <div class="twoCol">
            <div>
              <div class="lbl">C·ª≠a s·ªï ng√†y (N)</div>
              <input id="winN" type="number" min="5" max="120" value="30" />
            </div>
            <div>
              <div class="lbl">Top hi·ªÉn th·ªã</div>
              <input id="topK" type="number" min="5" max="50" value="15" />
            </div>
          </div>
          <div class="twoCol">
            <div>
              <div class="lbl">Tr·ªçng s·ªë Hot</div>
              <input id="wHot" type="number" step="0.1" value="2" />
            </div>
            <div>
              <div class="lbl">Tr·ªçng s·ªë Gan</div>
              <input id="wGan" type="number" step="0.1" value="1.5" />
            </div>
          </div>
          <div>
            <div class="lbl">Tr·ªçng s·ªë Pascal (ƒë∆°n gi·∫£n)</div>
            <input id="wPas" type="number" step="0.1" value="2" />
          </div>

          <div class="sep"></div>

          <div class="lbl">K·∫øt qu·∫£ FULL</div>
          <textarea id="fullOut" readonly></textarea>

          <div class="small">¬© B√πi H√†o ‚Äî Tool th·ªëng k√™ h·ªó tr·ª£ ph√¢n t√≠ch. Kh√¥ng ƒë·∫£m b·∫£o tr√∫ng.</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Tesseract.js CDN -->
  <script>
    // ====== Upload-Fix / Mobile rules ======
    const isHttps = location.protocol === 'https:' || location.hostname === 'localhost';
    const chipHttps = document.getElementById('chipHttps');
    chipHttps.textContent = 'HTTPS: ' + (isHttps ? 'OK' : 'FAIL');
    chipHttps.className = 'chip ' + (isHttps ? 'good' : 'bad');

    const fileInput = document.getElementById('fileInput');
    const btnPaste = document.getElementById('btnPaste');
    const btnClear = document.getElementById('btnClear');
    const btnRunFull = document.getElementById('btnRunFull');

    const imgPreview = document.getElementById('imgPreview');
    const noPreview = document.getElementById('noPreview');

    const chipTess = document.getElementById('chipTess');
    const chipBatch = document.getElementById('chipBatch');
    const chipGate  = document.getElementById('chipGate');

    const outDB = document.getElementById('outDB');
    const outG6 = document.getElementById('outG6');
    const outG7 = document.getElementById('outG7');
    const outStatus = document.getElementById('outStatus');

    const dbg = document.getElementById('dbg');
    const data = document.getElementById('data');
    const fullOut = document.getElementById('fullOut');

    const manDB = document.getElementById('manDB');
    const manG6 = document.getElementById('manG6');
    const manG7 = document.getElementById('manG7');
    const btnManualAdd = document.getElementById('btnManualAdd');

    const btnCopyAll = document.getElementById('btnCopyAll');
    const btnClearData = document.getElementById('btnClearData');

    const winN = document.getElementById('winN');
    const topK = document.getElementById('topK');
    const wHot = document.getElementById('wHot');
    const wGan = document.getElementById('wGan');
    const wPas = document.getElementById('wPas');

    let images = []; // {name, file, url}

    function setGate(status, msg=''){
      chipGate.textContent = 'Gate: ' + status;
      if(status==='PASS'){ chipGate.className='chip good'; outStatus.textContent='PASS'; outStatus.style.color='var(--good)'; }
      else if(status==='FAIL'){ chipGate.className='chip bad'; outStatus.textContent='FAIL'; outStatus.style.color='var(--bad)'; }
      else { chipGate.className='chip'; outStatus.textContent='‚Äî'; outStatus.style.color=''; }
      if(msg) dbg.value = (dbg.value ? dbg.value + "\n\n" : "") + msg;
    }

    function setBatch(ok, fail){
      chipBatch.textContent = `Batch: ${ok} OK | ${fail} FAIL`;
      chipBatch.className = 'chip ' + (fail===0 && ok>0 ? 'good' : (ok===0 ? '' : 'warn'));
    }

    function showPreview(url){
      imgPreview.src = url;
      imgPreview.classList.remove('hide');
      noPreview.classList.add('hide');
    }

    function clearAll(){
      images.forEach(x => URL.revokeObjectURL(x.url));
      images = [];
      fileInput.value = '';
      imgPreview.classList.add('hide');
      noPreview.classList.remove('hide');
      outDB.textContent='‚Äî'; outG6.textContent='‚Äî'; outG7.textContent='‚Äî';
      setGate('‚Äî');
      dbg.value='';
      setBatch(0,0);
    }

    btnClear.addEventListener('click', clearAll);

    // Paste image from clipboard (some Android browsers allow)
    btnPaste.addEventListener('click', async () => {
      try{
        const items = await navigator.clipboard.read();
        let added = 0;
        for(const it of items){
          for(const type of it.types){
            if(type.startsWith('image/')){
              const blob = await it.getType(type);
              const file = new File([blob], `paste_${Date.now()}.png`, {type});
              addFiles([file]);
              added++;
            }
          }
        }
        if(!added) alert('Kh√¥ng th·∫•y ·∫£nh trong clipboard.');
      }catch(e){
        alert('Tr√¨nh duy·ªát kh√¥ng cho d√°n ·∫£nh. Th·ª≠ Chrome + HTTPS.');
      }
    });

    fileInput.addEventListener('change', (e) => addFiles([...e.target.files]));

    function addFiles(files){
      if(!files || !files.length) return;
      for(const f of files){
        const url = URL.createObjectURL(f);
        images.push({name:f.name, file:f, url});
      }
      showPreview(images[images.length-1].url);
      setBatch(images.length, 0);
      setGate('‚Äî');
      dbg.value = '';
    }

    // ====== OCR (Tesseract.js) ======
    let TESS_READY = false;

    async function ensureTesseract(){
      if(TESS_READY) return true;
      chipTess.textContent = 'Tesseract: ƒëang t·∫£i‚Ä¶';
      chipTess.className = 'chip warn';
      // load tesseract.js on demand
      await new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js';
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
      });
      TESS_READY = true;
      chipTess.textContent = 'Tesseract: ready';
      chipTess.className = 'chip good';
      return true;
    }

    function normalizeOCR(raw){
      // normalize common OCR confusions WITHOUT breaking numbers too much
      let s = raw || '';
      // unify Vietnamese ƒêB/DB variants
      s = s.replace(/ƒêB/g, 'DB');
      // fix typical letter->digit confusions in numeric zones:
      // We'll do conservative replacement only when surrounded by non-letters.
      const map = [
        [/O/g,'0'], [/o/g,'0'],
        [/I/g,'1'], [/l/g,'1'], [/|/g,'1'],
        [/S/g,'5'], [/s/g,'5'],
        [/B/g,'8']
      ];
      // Apply only in lines that have many digits (likely table)
      const lines = s.split(/\r?\n/).map(line=>{
        const digitCount = (line.match(/\d/g)||[]).length;
        if(digitCount >= 6){
          let t = line;
          for(const [re, rep] of map) t = t.replace(re, rep);
          return t;
        }
        return line;
      });
      s = lines.join('\n');

      // collapse spaces
      s = s.replace(/[ \t]+/g,' ').replace(/\u00A0/g,' ');
      return s;
    }

    function linesClean(s){
      return normalizeOCR(s)
        .split(/\r?\n/)
        .map(x => x.trim())
        .filter(x => x.length>0);
    }

    function extractTokens(line){
      // keep only digits and spaces
      const pure = line.replace(/[^\d ]+/g,' ').replace(/[ ]+/g,' ').trim();
      const toks = pure ? pure.split(' ') : [];
      return toks.filter(Boolean);
    }

    function findDB(lines){
      // Strategy:
      // 1) find a line containing "DB" (label), then look for 5-digit number in same line or next 2 lines.
      // 2) pick the best 5-digit candidate, then last2 = DB 2 s·ªë.
      let cand = null;

      for(let i=0;i<lines.length;i++){
        const L = lines[i];
        if(/\bDB\b/.test(L) || /^DB\b/.test(L)){
          // scan current + next 2 lines for 5 digits
          const scan = [lines[i], lines[i+1]||'', lines[i+2]||''].join(' ');
          const m = scan.match(/\b\d{5}\b/g);
          if(m && m.length){
            // choose the first 5-digit after DB if possible
            cand = m[0];
            break;
          }
        }
      }

      // fallback: find any 5-digit in all text, but prefer near DB context (not ideal)
      if(!cand){
        const all = lines.join(' ');
        const m = all.match(/\b\d{5}\b/g);
        if(m && m.length) cand = m[0];
      }

      if(!cand) return {db5:null, db2:null};
      const db2 = cand.slice(-2);
      return {db5:cand, db2};
    }

    function isDateLine(line){
      // block date-like lines that created "30 01 12 12"
      // if contains 202x or has slashes or too many 1-2 digit tokens but with month/day pattern
      if(/[\/\-]\d/.test(line)) return true;
      if(/\b20\d{2}\b/.test(line)) return true;
      // "Th·ª©" / "√¢m l·ªãch" etc
      if(/thu|am lich|√¢m l·ªãch|mien bac|x·ªï s·ªë/i.test(line)) return true;
      return false;
    }

    function findG7(lines){
      // Strategy:
      // Find a line representing prize 7 row.
      // Must NOT be date line.
      // Must contain at least 4 two-digit tokens.
      // Must either:
      //   - start with "7" token (like "7 03 82 85 81") OR
      //   - contain a standalone "7" near start.
      // Then pick LAST 4 two-digit tokens (handles "7 1 03 82 85 81")
      for(const L0 of lines){
        const L = L0.trim();
        if(isDateLine(L)) continue;

        // Must have '7' label
        // Accept patterns: starts with 7 OR contains " 7 " with numbers around
        const has7 = /^\s*7\b/.test(L) || /\b7\b/.test(L);
        if(!has7) continue;

        const tokens = extractTokens(L); // includes prize label and numbers
        if(tokens.length < 5) continue;

        // collect two-digit tokens only (00-99)
        const two = tokens.filter(t => /^\d{2}$/.test(t));
        if(two.length >= 4){
          const last4 = two.slice(-4);
          return {g7:last4.map(x=>x.padStart(2,'0'))};
        }
      }

      // fallback: search all lines for 4 two-digit tokens and prefer line with 7
      return {g7:null};
    }

    function findG6(lines){
      // Strategy:
      // Find a line with prize 6 label and 3 numbers of 3 digits.
      // pick LAST 3 three-digit tokens (handles noise).
      for(const L0 of lines){
        const L = L0.trim();
        if(isDateLine(L)) continue;
        const has6 = /^\s*6\b/.test(L) || /\b6\b/.test(L);
        if(!has6) continue;

        const tokens = extractTokens(L);
        const three = tokens.filter(t => /^\d{3}$/.test(t));
        if(three.length >= 3){
          const last3 = three.slice(-3);
          return {g6:last3};
        }
      }
      return {g6:null};
    }

    function gateCheck(parsed){
      // Gate c·ª©ng: DB2 must 2 digits; G7 must 4 x 2 digits; G6 must 3 x 3 digits
      const okDB = parsed.db2 && /^\d{2}$/.test(parsed.db2);
      const okG7 = parsed.g7 && parsed.g7.length===4 && parsed.g7.every(x=>/^\d{2}$/.test(x));
      const okG6 = parsed.g6 && parsed.g6.length===3 && parsed.g6.every(x=>/^\d{3}$/.test(x));
      return {pass: okDB && okG7 && okG6, okDB, okG7, okG6};
    }

    async function ocrOne(file){
      await ensureTesseract();
      const { createWorker } = Tesseract;
      const worker = await createWorker('eng'); // numbers mostly ok in eng
      try{
        await worker.setParameters({
          tessedit_char_whitelist: "0123456789DBdbƒêƒë /:-\n",
          preserve_interword_spaces: "1",
        });
        const r = await worker.recognize(file);
        return r.data.text || '';
      } finally {
        await worker.terminate();
      }
    }

    async function processBatch(){
      if(!images.length){
        alert('Ch∆∞a c√≥ ·∫£nh.');
        return;
      }
      btnRunFull.disabled = true;

      let ok=0, fail=0;
      dbg.value = '';
      setGate('‚Äî');
      outDB.textContent='‚Äî'; outG6.textContent='‚Äî'; outG7.textContent='‚Äî';

      for(let idx=0; idx<images.length; idx++){
        const it = images[idx];
        showPreview(it.url);

        dbg.value = `=== OCR ${idx+1}/${images.length} : ${it.name} ===\n`;
        let raw = '';
        try{
          raw = await ocrOne(it.file);
        }catch(e){
          fail++;
          dbg.value += `OCR ERROR: ${String(e)}\n`;
          continue;
        }

        const lines = linesClean(raw);

        // Build debug short
        dbg.value += `[OCR_RAW]\n` + raw.slice(0, 1800) + (raw.length>1800?'\n‚Ä¶(c·∫Øt)‚Ä¶\n':'\n');
        dbg.value += `\n[LINES]\n` + lines.slice(0, 80).join('\n') + (lines.length>80?'\n‚Ä¶(c·∫Øt)‚Ä¶\n':'\n');

        const db = findDB(lines);
        const g7 = findG7(lines);
        const g6 = findG6(lines);

        const parsed = { db5:db.db5, db2:db.db2, g7:g7.g7, g6:g6.g6 };
        const gate = gateCheck(parsed);

        // show outputs
        outDB.textContent = parsed.db2 ? parsed.db2 : '‚Äî';
        outG6.textContent = parsed.g6 ? parsed.g6.join(' ') : '‚Äî';
        outG7.textContent = parsed.g7 ? parsed.g7.join(' ') : '‚Äî';

        // explain
        dbg.value += `\n[PARSE]\nDB_5DIG: ${parsed.db5||'‚Äî'}\nDB_2: ${parsed.db2||'‚Äî'}\nG7: ${parsed.g7?parsed.g7.join(' '):'‚Äî'}\nG6: ${parsed.g6?parsed.g6.join(' '):'‚Äî'}\n`;
        dbg.value += `[GATE] pass=${gate.pass} (DB=${gate.okDB}, G7=${gate.okG7}, G6=${gate.okG6})\n`;

        if(gate.pass){
          ok++;
          setGate('PASS');
          // push to data (DB is 2 s·ªë, as H√†o d√πng)
          const line = `DB ${parsed.db2} | G7: ${parsed.g7.join(' ')} | G6: ${parsed.g6.join(' ')}`;
          appendDataLine(line);
        }else{
          fail++;
          setGate('FAIL');
        }
        setBatch(ok, fail);
      }

      btnRunFull.disabled = false;
      setBatch(ok, fail);
      if(ok===0) setGate('FAIL', '\n‚ö†Ô∏è Kh√¥ng c√≥ ·∫£nh n√†o PASS. D√πng Manual ƒë·ªÉ th√™m ƒë√∫ng 1 d√≤ng r·ªìi ch·∫°y FULL.');
    }

    function appendDataLine(line){
      const cur = data.value.trim();
      data.value = cur ? (cur + "\n" + line) : line;
    }

    btnRunFull.addEventListener('click', async () => {
      await processBatch();
      runFull();
    });

    btnManualAdd.addEventListener('click', () => {
      const db = (manDB.value||'').trim();
      const g6 = (manG6.value||'').trim();
      const g7 = (manG7.value||'').trim();

      // validate strict
      const okDB = /^\d{2}$/.test(db);
      const g6t = g6.split(/\s+/).filter(Boolean);
      const g7t = g7.split(/\s+/).filter(Boolean);
      const okG6 = g6t.length===3 && g6t.every(x=>/^\d{3}$/.test(x));
      const okG7 = g7t.length===4 && g7t.every(x=>/^\d{2}$/.test(x));

      if(!okDB || !okG6 || !okG7){
        alert('Manual ch∆∞a ƒë√∫ng format.\nDB: 2 s·ªë\nG7: 4 s·ªë (2 ch·ªØ s·ªë)\nG6: 3 s·ªë (3 ch·ªØ s·ªë)');
        return;
      }
      appendDataLine(`DB ${db} | G7: ${g7t.join(' ')} | G6: ${g6t.join(' ')}`);
      setGate('PASS');
      chipGate.textContent = 'Gate: PASS (manual)';
      chipGate.className = 'chip good';
    });

    btnCopyAll.addEventListener('click', async()=>{
      try{
        await navigator.clipboard.writeText(data.value);
        alert('ƒê√£ copy d·ªØ li·ªáu.');
      }catch(e){
        alert('Kh√¥ng copy ƒë∆∞·ª£c (tr√¨nh duy·ªát ch·∫∑n). H√£y b√¥i ƒëen v√† copy th·ªß c√¥ng.');
      }
    });

    btnClearData.addEventListener('click', ()=> data.value='');

    // ====== FULL analysis (nh·∫π, ƒë·ªß d√πng) ======
    function parseDataLines(){
      const lines = data.value.split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
      // Keep last N
      const N = Math.max(5, Math.min(120, Number(winN.value||30)));
      const use = lines.slice(-N);

      const rows = [];
      for(const L of use){
        // DB xx | G7: a b c d | G6: xxx yyy zzz
        const mDB = L.match(/\bDB\s+(\d{2})\b/i);
        const mG7 = L.match(/\bG7:\s*([0-9 ]{8,})/i);
        const mG6 = L.match(/\bG6:\s*([0-9 ]{11,})/i);
        if(!mDB || !mG7 || !mG6) continue;

        const db = mDB[1];
        const g7 = mG7[1].trim().split(/\s+/).filter(Boolean).slice(0,4);
        const g6 = mG6[1].trim().split(/\s+/).filter(Boolean).slice(0,3);

        if(g7.length!==4 || g6.length!==3) continue;
        if(!g7.every(x=>/^\d{2}$/.test(x))) continue;
        if(!g6.every(x=>/^\d{3}$/.test(x))) continue;

        // hot pool: DB + all G7 + last2 of each G6 3-digit
        const g6_2 = g6.map(x=>x.slice(-2));
        rows.push({db, g7, g6, g6_2});
      }
      return rows;
    }

    function runFull(){
      const rows = parseDataLines();
      const Nneed = 5;
      if(rows.length < Nneed){
        fullOut.value = `‚úó Thi·∫øu d·ªØ li·ªáu: c·∫ßn √≠t nh·∫•t ${Nneed} d√≤ng (5 ng√†y). Hi·ªán c√≥: ${rows.length}\n`;
        return;
      }

      const K = Math.max(5, Math.min(50, Number(topK.value||15)));
      const wH = Number(wHot.value||2);
      const wG = Number(wGan.value||1.5);
      const wP = Number(wPas.value||2);

      // Build sequence of "2-digit" outcomes to score: union set per day
      const seq = rows.map(r => {
        const set = new Set();
        set.add(r.db);
        r.g7.forEach(x=>set.add(x));
        r.g6_2.forEach(x=>set.add(x));
        return set;
      });

      // hot count
      const hot = new Map();
      for(const s of seq){
        for(const x of s) hot.set(x, (hot.get(x)||0)+1);
      }

      // gan: days since last appeared (higher = more gan)
      const allNums = Array.from(hot.keys());
      const gan = new Map();
      for(const num of allNums){
        let last = -1;
        for(let i=seq.length-1;i>=0;i--){
          if(seq[i].has(num)){ last = i; break; }
        }
        gan.set(num, last===-1 ? seq.length : (seq.length-1-last));
      }

      // simple pascal-ish: bonus if overlaps between last-day and previous-day (momentum)
      // (kept simple to avoid ‚Äú·∫£o‚Äù)
      const pas = new Map();
      for(const num of allNums) pas.set(num, 0);
      for(let i=1;i<seq.length;i++){
        for(const num of seq[i]){
          if(seq[i-1].has(num)) pas.set(num, pas.get(num)+1);
        }
      }

      // score
      const scored = allNums.map(num => {
        const h = hot.get(num)||0;
        const g = gan.get(num)||0;
        const p = pas.get(num)||0;
        const score = h*wH + g*wG + p*wP;
        return {num, h, g, p, score};
      }).sort((a,b)=> b.score - a.score || b.h - a.h || b.g - a.g);

      const topHot = [...scored].sort((a,b)=> b.h-a.h).slice(0, K);
      const topScore = scored.slice(0, K);

      const pickMain = topScore[0]?.num || '‚Äî';
      const pickSub  = topScore[1]?.num || '‚Äî';

      let out = '';
      out += `T·ªïng ng√†y (h·ª£p l·ªá): ${rows.length}\n\n`;

      out += `TOP HOT:\n`;
      for(const x of topHot){
        out += `${x.num} -> ${x.h}\n`;
      }

      out += `\nTOP SCORE (hot+gan+pas):\n`;
      for(const x of topScore){
        out += `${x.num} -> ${x.score.toFixed(2)}   (hot=${x.h}, gan=${x.g}, pas=${x.p})\n`;
      }

      out += `\nCH·ªêT G·ª¢I √ù:\nüéØ Ch√≠nh: ${pickMain}\nü•à Ph·ª•:  ${pickSub}\n`;
      out += `\n* Tool th·ªëng k√™ h·ªó tr·ª£, kh√¥ng ƒë·∫£m b·∫£o tr√∫ng.\n`;

      fullOut.value = out;
    }

    document.getElementById('btnRunFull').addEventListener('click', runFull);
    [data, winN, topK, wHot, wGan, wPas].forEach(el => el.addEventListener('input', () => {
      // optional live update
    }));

    // Auto run if user edits then presses Run FULL
    document.getElementById('btnRunFull').addEventListener('click', runFull);

    // ====== Kickstart ======
    setBatch(0,0);
    setGate('‚Äî');

    // Extra: prevent ‚ÄúPASS sai‚Äù do G7 b·ªã ƒÉn ng√†y/th√°ng:
    // => Gate PASS ch·ªâ khi parse G7 ƒë∆∞·ª£c t·ª´ d√≤ng c√≥ nh√£n 7 + ƒë·ªß 4 s·ªë 2 ch·ªØ s·ªë.
    // (ƒë√£ x·ª≠ l√Ω b·∫±ng findG7 + isDateLine)
  </script>
</body>
</html>
